
- [ ] [[#1. Enumération initiale]]
- [ ] [[#2. EyeWitness / Aquatone]]
- [ ] [[#3. FINGERPRINTING]]
- [ ] [[#4. FUZZING]]
- [ ] [[#5. CRAWLING]]
- [ ] [[#5. CVEs]]



- [[#CMS]]
- [[#Servlet Containers/Software Development]]
- [[#Web Servers]]
- [[#Infrastructure/Network Monitoring Tools]]
- [[#Ticketing Services]]
- [[#CGI (Common Gateway Interface)]]
- [[#Clients Lourds (thick client)]]


[[#HARDENING]]



---

# 1. Enumération initiale


1. créer une scope liste avec les machines à scanner

2. Scan Nmap des ports 80,443,8000,8080,8180,8888,10000 sur la liste dans un premier temps

```shell
sudo nmap -sS -sV -sC -p 80,443,8000,8080,8180,8888,10000 --open -oA web_discovery -iL scope_list -vv
```

3. Scan Nmap des 1000 ports les plus utilisés sur la liste dans un second temps

```shell
sudo nmap -sS -sV -sC --open -oA web_discovery_top1k -iL scope_list 
```

3. Scan Nmap des 10000 ports les plus utilisés sur la liste dans un second temps

```shell
sudo nmap -sS -sV -sC --top-ports 10000 --open -oA web_discovery_top10k -iL scope_list 
```

5. Faire le tri sur les hôtes qui ont l'air intéressant (app.domain.local / gitlab-dev.domain.local par ex) dans un fichier 'interesting_hosts'

6. Scan Nmap de tous les ports et services sur la liste d'hôtes intéressants

```shell
sudo nmap -p- --open -sS -sV -sC -oA web_discovery_interesting_hosts -iL interesting_hosts 
```


---

# 2. EyeWitness / Aquatone

> [!TIP]
> Permet de screenshot les applications et identifier les cibles interessantes.

## EyeWitness

https://github.com/RedSiege/EyeWitness

```shell
sudo apt install eyewitness
```

1. Lancer eyewitness sur resultat Nmap au format XML

```shell
eyewitness --web -x web_discovery.xml -d <domain>
```

ou sur fichier contenant les url

```
eyewitness --web -f subdomains.txt
```

Préciser ports a screenshots

```shell
eyewitness --web -x web_discovery.xml -d <domain> --only-ports 80,8081,8060,443
```


## Aquatone

https://github.com/shelld3v/aquatone

```shell
wget https://github.com/michenriksen/aquatone/releases/download/v1.7.0/aquatone_linux_amd64_1.7.0.zip
```

```shell
unzip aquatone_linux_amd64_1.7.0.zip 
```


1. Lancer aquatone sur resultat Nmap au format XML

```shell
cat web_discovery.xml | ./aquatone -nmap
```



---
# 3. FINGERPRINTING

[[3. FINGERPRINTING]]



---
# 4. FUZZING

[[8. FUZZING]]


---

# 5. CRAWLING

[[4. CRAWLING]]


---

# 6. CVEs

[[1. Recherche de CVEs]]


---

# CMS


- [[WORDPRESS]]
- [[JOOMLA]]
- [[DRUPAL]]
- [[COLDFUSION]]
- [[DOTNETNUKE]]

**Automated Scanners**

- clusterd (jboss,coldfusion,weblogic,tomcat,railo,axis2,glassfish) 
- cmsmap (wordpress,joomla,drupal,moodle)
- cmsscan (wordpress, drupal, joomla, vbulletin)
- vulnx (prestashop, opencart, joomla, wordpress, drupal, lokomedia)
- droopescan (silverstripe,wordpress, drupal, joomla,moodle)
- wpscan (wordpress)
- joomscan(joomla)
- magescan (Magento)

---

# Servlet Containers/Software Development

- [[TOMCAT]]
- [[JENKINS]]
- [[GITLAB]]

---

# Web Servers

- [[APACHE]]
- [[IIS]]
- [[NGINX]]



---
# Infrastructure/Network Monitoring Tools

- [[SPLUNK]]
- [[PRTG]]

---

# Ticketing Services

- [[osTicket]]

---

# CGI (Common Gateway Interface)

> [!TIP]
> Middleware faisant la liaison entre serveur web et autres applications et permet d'exécuter des scripts.
> 

/CGI-bin -> répertoire contenant les scripts CGI au format .cgi

![[Pasted image 20250419052619.png]]


- [[TOMCAT#CVE-2019-0232 (9.0.0.M1 to 9.0.17, 8.5.0 to 8.5.39, and 7.0.0 to 7.0.93)]]
- [[SHELLSHOCK (Bash Bug)]]


---
# Clients Lourds (thick client)

![[Pasted image 20250419201010.png]]

Propice à :
- Improper Error Handling.
- Hardcoded sensitive data.
- DLL Hijacking.
- Buffer Overflow.
- SQL Injection.
- Insecure Storage.
- Session Management.

- [ ] [[#Enumération initiale]]
- [ ] [[#Exploitation Coté Client]]
- [ ] [[#Exploitation Coté Réseau]]
- [ ] [[#Exploitation Coté Serveur]]

## Enumération initiale

Identifier :
- L'architecture
- Le langage de programmation
- Les Frameworks utilisés
- Comprendre le fonctionnement de l'application
- Les technos utilisées en client side / server side
- Entry points (commencement du programme)
- User inputs


tools

- [CFF Explorer](https://ntcore.com/?page_id=388)
- [Detect It Easy](https://github.com/horsicq/Detect-It-Easy)
- [Process Monitor](https://learn.microsoft.com/en-us/sysinternals/downloads/procmon)
- [Strings](https://learn.microsoft.com/en-us/sysinternals/downloads/strings)

1. Transférer le programme sur notre machine
2. Lancer ProcMon
3. Lancer l'application afin d'identifier son comportement
4. Filtrer sur l'application dans procmon.
5. Si fichiers crées dans temp -> Désactiver la suppression des fichiers dans le dossier -> Dans ACL décocher "Delete subfolders and files"
6. Relancer l'application
7. Analyser les fichiers déposés dans temp
8. Si des fichiers déposés puis supprimés faire en sorte qu'ils ne soient pas supprimés en modifiant le code par ex
9. Analyser les fichiers crées (si scripts les lire et exécuter)
10. Réitérer le processus d'analyse avec Procmon...
11. Si pas plus d'infos passer à l'analyse statique avancée -> [[#Exploitation Coté Client]]


## Exploitation Coté Client

Reverse Engineering

| [Ghidra](https://www.ghidra-sre.org/)   | [IDA](https://hex-rays.com/ida-pro/) | [OllyDbg](http://www.ollydbg.de/)      | [Radare2](https://www.radare.org/r/index.html) |
| --------------------------------------- | ------------------------------------ | -------------------------------------- | ---------------------------------------------- |
| [dnSpy](https://github.com/dnSpy/dnSpy) | [x64dbg](https://x64dbg.com/)        | [JADX](https://github.com/skylot/jadx) | [Frida](https://frida.re/)                     |

### x64dbg (Débug le programme et donc l'exécute):

1. Lancer x64dbg
2. Dans options -> Préférences -> Décocher tout sauf "Exit Breakpoint" (permet de charger l'entry point du programme directement)
3. File -> Open -> Selectionner le programme
4. Clique droit dans CPU -> Follow In Memory Map
5. Identifier les types MAP ayant la protection RW (Les fichiers MAP permettent à l'application d'accéder à des gros fichiers sans avoir besoin de lire ou ecrire le fichier en entier en mémoire) -> Peut être intéressant pour trouver des Creds codés en dur.
6. Double cliquer sur la ligne pour identifier le Magic Number
7. Revenir à la ligne dans Memory Map -> Clique droit sur l'adresse -> Dump Memory to file

Strings: 

1. Lancer Strings sur le dump memoire

```powershell-session
C:\TOOLS\Strings\strings64.exe .\restart-service_00000000001E0000.bin
```

Si dump contient un executable DotNet -> Décompiler avec De4Dot https://github.com/de4dot/de4dot

2. Drag and drop le .bin dans de4dot
3. Ouvrir le fichier créé
4. Lire le code source

### Dnspy:

1. Lancer le .bin créé avec Dnspy
2. Developper l'arborescence jusqu'a trouver Program -> Lire code 


Trouver hardcoded credentials -> Ouvrir le fichier cible uniquement -> search -> password -> search for Number / String

## Exploitation Coté Réseau


Sniffing du trafic

| [Wireshark](https://www.wireshark.org/) | [tcpdump](https://www.tcpdump.org/) | [TCPView](https://learn.microsoft.com/en-us/sysinternals/downloads/tcpview) | [Burp Suite](https://portswigger.net/burp) |
| --------------------------------------- | ----------------------------------- | --------------------------------------------------------------------------- | ------------------------------------------ |

SI application en 3 tiers, sniffer le trafic afin d'étudier les connexions vers serveurs etc...

Si besoin de changer des ports / ip pour communiquer avec db -> reverse


Recherche du port 8000 dans les fichiers d'un .jar par ex.

```powershell
ls fatty-client\ -recurse | Select-String "8000" | Select Path, LineNumber | Format-List
```


Supprimer tous les hashs du META-INF\MANIFEST et les fichiers RSA et SF du dossier META-INF

Recompiler .jar

```powershell
jar -cmf .\META-INF\MANIFEST.MF ..\fatty-client-new.jar *
```

Après avoir décompilé et sauvegardé le code afin de le modifier -> Recompiler les .java pour obtenir des .class

```powershell
javac -cp fatty-client-new.jar fatty-client-new.jar.src\htb\fatty\client\gui\*.java
```

Puis remplacer les .class originaux par les nouveaux .class générés

Recompiler une nouvelle fois

```powershell
jar -cmf .\META-INF\MANIFEST.MF ..\fatty-client-new.jar *
```

## Exploitation Coté Serveur

Similaire au pentest web -> OWASP



---


# HARDENING


- `Secure authentication`: Applications should enforce strong passwords during registration and setup, and default administrative account passwords should be changed. If possible, the default administrative accounts should be disabled, with new custom administrative accounts created. Some applications inherently support 2FA authentication, which should be made mandatory for at least administrator-level users.
    
- `Access controls`: Proper access control mechanisms should be implemented per application. For example, login pages should not be accessible from the external network unless there is a valid business reason for this access. Similarly, file and folder permissions can be configured to deny uploads or application deployments.
    
- `Disable unsafe features`: Features such as PHP code editing in WordPress can be disabled to prevent code execution if the server is compromised.
    
- `Regular updates`: Applications should be updated regularly, and patches supplied by vendors should be applied as soon as possible.
    
- `Backups`: System administrators should always configure website and database backups, allowing the application to be quickly restored in case of a compromise.
    
- `Security monitoring`: There are various tools and plugins that can be used to monitor the status and various security-related issues for our applications. Another option is a Web Application Firewall (WAF). While not a silver bullet, a WAF can help add an extra layer of protection provided all the measures above have already been taken.
    
- `LDAP integration with Active Directory`: Integrating applications with Active Directory single sign-on can increase ease of access, provide more auditing functionality (especially if synced with Azure), and make managing credentials and service accounts more streamlined. It also decreases the number of accounts and passwords that a user will have to remember and give fine-grained control over the password policy.